
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model anime
 * 
 */
export type anime = $Result.DefaultSelection<Prisma.$animePayload>
/**
 * Model follows
 * 
 */
export type follows = $Result.DefaultSelection<Prisma.$followsPayload>
/**
 * Model groupmembers
 * 
 */
export type groupmembers = $Result.DefaultSelection<Prisma.$groupmembersPayload>
/**
 * Model groups
 * 
 */
export type groups = $Result.DefaultSelection<Prisma.$groupsPayload>
/**
 * Model likes
 * 
 */
export type likes = $Result.DefaultSelection<Prisma.$likesPayload>
/**
 * Model listitems
 * 
 */
export type listitems = $Result.DefaultSelection<Prisma.$listitemsPayload>
/**
 * Model lists
 * 
 */
export type lists = $Result.DefaultSelection<Prisma.$listsPayload>
/**
 * Model movies
 * 
 */
export type movies = $Result.DefaultSelection<Prisma.$moviesPayload>
/**
 * Model songs
 * 
 */
export type songs = $Result.DefaultSelection<Prisma.$songsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model videogames
 * 
 */
export type videogames = $Result.DefaultSelection<Prisma.$videogamesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const listtype: {
  anime: 'anime',
  movies: 'movies',
  songs: 'songs',
  videogames: 'videogames'
};

export type listtype = (typeof listtype)[keyof typeof listtype]

}

export type listtype = $Enums.listtype

export const listtype: typeof $Enums.listtype

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Anime
 * const anime = await prisma.anime.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Anime
   * const anime = await prisma.anime.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.anime`: Exposes CRUD operations for the **anime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Anime
    * const anime = await prisma.anime.findMany()
    * ```
    */
  get anime(): Prisma.animeDelegate<ExtArgs>;

  /**
   * `prisma.follows`: Exposes CRUD operations for the **follows** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follows.findMany()
    * ```
    */
  get follows(): Prisma.followsDelegate<ExtArgs>;

  /**
   * `prisma.groupmembers`: Exposes CRUD operations for the **groupmembers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groupmembers
    * const groupmembers = await prisma.groupmembers.findMany()
    * ```
    */
  get groupmembers(): Prisma.groupmembersDelegate<ExtArgs>;

  /**
   * `prisma.groups`: Exposes CRUD operations for the **groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.groups.findMany()
    * ```
    */
  get groups(): Prisma.groupsDelegate<ExtArgs>;

  /**
   * `prisma.likes`: Exposes CRUD operations for the **likes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.likes.findMany()
    * ```
    */
  get likes(): Prisma.likesDelegate<ExtArgs>;

  /**
   * `prisma.listitems`: Exposes CRUD operations for the **listitems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Listitems
    * const listitems = await prisma.listitems.findMany()
    * ```
    */
  get listitems(): Prisma.listitemsDelegate<ExtArgs>;

  /**
   * `prisma.lists`: Exposes CRUD operations for the **lists** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lists
    * const lists = await prisma.lists.findMany()
    * ```
    */
  get lists(): Prisma.listsDelegate<ExtArgs>;

  /**
   * `prisma.movies`: Exposes CRUD operations for the **movies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movies
    * const movies = await prisma.movies.findMany()
    * ```
    */
  get movies(): Prisma.moviesDelegate<ExtArgs>;

  /**
   * `prisma.songs`: Exposes CRUD operations for the **songs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Songs
    * const songs = await prisma.songs.findMany()
    * ```
    */
  get songs(): Prisma.songsDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.videogames`: Exposes CRUD operations for the **videogames** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videogames
    * const videogames = await prisma.videogames.findMany()
    * ```
    */
  get videogames(): Prisma.videogamesDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.15.0
   * Query Engine version: e9771e62de70f79a5e1c604a2d7c8e2a0a874b48
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    anime: 'anime',
    follows: 'follows',
    groupmembers: 'groupmembers',
    groups: 'groups',
    likes: 'likes',
    listitems: 'listitems',
    lists: 'lists',
    movies: 'movies',
    songs: 'songs',
    users: 'users',
    videogames: 'videogames'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'anime' | 'follows' | 'groupmembers' | 'groups' | 'likes' | 'listitems' | 'lists' | 'movies' | 'songs' | 'users' | 'videogames'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      anime: {
        payload: Prisma.$animePayload<ExtArgs>
        fields: Prisma.animeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.animeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.animeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animePayload>
          }
          findFirst: {
            args: Prisma.animeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.animeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animePayload>
          }
          findMany: {
            args: Prisma.animeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animePayload>[]
          }
          create: {
            args: Prisma.animeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animePayload>
          }
          createMany: {
            args: Prisma.animeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.animeCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animePayload>[]
          }
          delete: {
            args: Prisma.animeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animePayload>
          }
          update: {
            args: Prisma.animeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animePayload>
          }
          deleteMany: {
            args: Prisma.animeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.animeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.animeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$animePayload>
          }
          aggregate: {
            args: Prisma.AnimeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAnime>
          }
          groupBy: {
            args: Prisma.animeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AnimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.animeCountArgs<ExtArgs>,
            result: $Utils.Optional<AnimeCountAggregateOutputType> | number
          }
        }
      }
      follows: {
        payload: Prisma.$followsPayload<ExtArgs>
        fields: Prisma.followsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.followsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$followsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.followsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$followsPayload>
          }
          findFirst: {
            args: Prisma.followsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$followsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.followsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$followsPayload>
          }
          findMany: {
            args: Prisma.followsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$followsPayload>[]
          }
          create: {
            args: Prisma.followsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$followsPayload>
          }
          createMany: {
            args: Prisma.followsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.followsCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$followsPayload>[]
          }
          delete: {
            args: Prisma.followsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$followsPayload>
          }
          update: {
            args: Prisma.followsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$followsPayload>
          }
          deleteMany: {
            args: Prisma.followsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.followsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.followsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$followsPayload>
          }
          aggregate: {
            args: Prisma.FollowsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFollows>
          }
          groupBy: {
            args: Prisma.followsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FollowsGroupByOutputType>[]
          }
          count: {
            args: Prisma.followsCountArgs<ExtArgs>,
            result: $Utils.Optional<FollowsCountAggregateOutputType> | number
          }
        }
      }
      groupmembers: {
        payload: Prisma.$groupmembersPayload<ExtArgs>
        fields: Prisma.groupmembersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.groupmembersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupmembersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.groupmembersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupmembersPayload>
          }
          findFirst: {
            args: Prisma.groupmembersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupmembersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.groupmembersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupmembersPayload>
          }
          findMany: {
            args: Prisma.groupmembersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupmembersPayload>[]
          }
          create: {
            args: Prisma.groupmembersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupmembersPayload>
          }
          createMany: {
            args: Prisma.groupmembersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.groupmembersCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupmembersPayload>[]
          }
          delete: {
            args: Prisma.groupmembersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupmembersPayload>
          }
          update: {
            args: Prisma.groupmembersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupmembersPayload>
          }
          deleteMany: {
            args: Prisma.groupmembersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.groupmembersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.groupmembersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupmembersPayload>
          }
          aggregate: {
            args: Prisma.GroupmembersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGroupmembers>
          }
          groupBy: {
            args: Prisma.groupmembersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GroupmembersGroupByOutputType>[]
          }
          count: {
            args: Prisma.groupmembersCountArgs<ExtArgs>,
            result: $Utils.Optional<GroupmembersCountAggregateOutputType> | number
          }
        }
      }
      groups: {
        payload: Prisma.$groupsPayload<ExtArgs>
        fields: Prisma.groupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.groupsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.groupsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          findFirst: {
            args: Prisma.groupsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.groupsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          findMany: {
            args: Prisma.groupsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>[]
          }
          create: {
            args: Prisma.groupsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          createMany: {
            args: Prisma.groupsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.groupsCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>[]
          }
          delete: {
            args: Prisma.groupsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          update: {
            args: Prisma.groupsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          deleteMany: {
            args: Prisma.groupsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.groupsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.groupsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          aggregate: {
            args: Prisma.GroupsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGroups>
          }
          groupBy: {
            args: Prisma.groupsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.groupsCountArgs<ExtArgs>,
            result: $Utils.Optional<GroupsCountAggregateOutputType> | number
          }
        }
      }
      likes: {
        payload: Prisma.$likesPayload<ExtArgs>
        fields: Prisma.likesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.likesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$likesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.likesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$likesPayload>
          }
          findFirst: {
            args: Prisma.likesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$likesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.likesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$likesPayload>
          }
          findMany: {
            args: Prisma.likesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$likesPayload>[]
          }
          create: {
            args: Prisma.likesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$likesPayload>
          }
          createMany: {
            args: Prisma.likesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.likesCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$likesPayload>[]
          }
          delete: {
            args: Prisma.likesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$likesPayload>
          }
          update: {
            args: Prisma.likesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$likesPayload>
          }
          deleteMany: {
            args: Prisma.likesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.likesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.likesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$likesPayload>
          }
          aggregate: {
            args: Prisma.LikesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLikes>
          }
          groupBy: {
            args: Prisma.likesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LikesGroupByOutputType>[]
          }
          count: {
            args: Prisma.likesCountArgs<ExtArgs>,
            result: $Utils.Optional<LikesCountAggregateOutputType> | number
          }
        }
      }
      listitems: {
        payload: Prisma.$listitemsPayload<ExtArgs>
        fields: Prisma.listitemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.listitemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listitemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.listitemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listitemsPayload>
          }
          findFirst: {
            args: Prisma.listitemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listitemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.listitemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listitemsPayload>
          }
          findMany: {
            args: Prisma.listitemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listitemsPayload>[]
          }
          create: {
            args: Prisma.listitemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listitemsPayload>
          }
          createMany: {
            args: Prisma.listitemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.listitemsCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listitemsPayload>[]
          }
          delete: {
            args: Prisma.listitemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listitemsPayload>
          }
          update: {
            args: Prisma.listitemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listitemsPayload>
          }
          deleteMany: {
            args: Prisma.listitemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.listitemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.listitemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listitemsPayload>
          }
          aggregate: {
            args: Prisma.ListitemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateListitems>
          }
          groupBy: {
            args: Prisma.listitemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ListitemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.listitemsCountArgs<ExtArgs>,
            result: $Utils.Optional<ListitemsCountAggregateOutputType> | number
          }
        }
      }
      lists: {
        payload: Prisma.$listsPayload<ExtArgs>
        fields: Prisma.listsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.listsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.listsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listsPayload>
          }
          findFirst: {
            args: Prisma.listsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.listsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listsPayload>
          }
          findMany: {
            args: Prisma.listsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listsPayload>[]
          }
          create: {
            args: Prisma.listsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listsPayload>
          }
          createMany: {
            args: Prisma.listsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.listsCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listsPayload>[]
          }
          delete: {
            args: Prisma.listsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listsPayload>
          }
          update: {
            args: Prisma.listsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listsPayload>
          }
          deleteMany: {
            args: Prisma.listsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.listsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.listsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$listsPayload>
          }
          aggregate: {
            args: Prisma.ListsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLists>
          }
          groupBy: {
            args: Prisma.listsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ListsGroupByOutputType>[]
          }
          count: {
            args: Prisma.listsCountArgs<ExtArgs>,
            result: $Utils.Optional<ListsCountAggregateOutputType> | number
          }
        }
      }
      movies: {
        payload: Prisma.$moviesPayload<ExtArgs>
        fields: Prisma.moviesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.moviesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$moviesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.moviesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$moviesPayload>
          }
          findFirst: {
            args: Prisma.moviesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$moviesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.moviesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$moviesPayload>
          }
          findMany: {
            args: Prisma.moviesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$moviesPayload>[]
          }
          create: {
            args: Prisma.moviesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$moviesPayload>
          }
          createMany: {
            args: Prisma.moviesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.moviesCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$moviesPayload>[]
          }
          delete: {
            args: Prisma.moviesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$moviesPayload>
          }
          update: {
            args: Prisma.moviesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$moviesPayload>
          }
          deleteMany: {
            args: Prisma.moviesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.moviesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.moviesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$moviesPayload>
          }
          aggregate: {
            args: Prisma.MoviesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMovies>
          }
          groupBy: {
            args: Prisma.moviesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MoviesGroupByOutputType>[]
          }
          count: {
            args: Prisma.moviesCountArgs<ExtArgs>,
            result: $Utils.Optional<MoviesCountAggregateOutputType> | number
          }
        }
      }
      songs: {
        payload: Prisma.$songsPayload<ExtArgs>
        fields: Prisma.songsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.songsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$songsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.songsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$songsPayload>
          }
          findFirst: {
            args: Prisma.songsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$songsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.songsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$songsPayload>
          }
          findMany: {
            args: Prisma.songsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$songsPayload>[]
          }
          create: {
            args: Prisma.songsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$songsPayload>
          }
          createMany: {
            args: Prisma.songsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.songsCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$songsPayload>[]
          }
          delete: {
            args: Prisma.songsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$songsPayload>
          }
          update: {
            args: Prisma.songsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$songsPayload>
          }
          deleteMany: {
            args: Prisma.songsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.songsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.songsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$songsPayload>
          }
          aggregate: {
            args: Prisma.SongsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSongs>
          }
          groupBy: {
            args: Prisma.songsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SongsGroupByOutputType>[]
          }
          count: {
            args: Prisma.songsCountArgs<ExtArgs>,
            result: $Utils.Optional<SongsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      videogames: {
        payload: Prisma.$videogamesPayload<ExtArgs>
        fields: Prisma.videogamesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.videogamesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videogamesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.videogamesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videogamesPayload>
          }
          findFirst: {
            args: Prisma.videogamesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videogamesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.videogamesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videogamesPayload>
          }
          findMany: {
            args: Prisma.videogamesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videogamesPayload>[]
          }
          create: {
            args: Prisma.videogamesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videogamesPayload>
          }
          createMany: {
            args: Prisma.videogamesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.videogamesCreateManyAndReturnArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videogamesPayload>[]
          }
          delete: {
            args: Prisma.videogamesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videogamesPayload>
          }
          update: {
            args: Prisma.videogamesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videogamesPayload>
          }
          deleteMany: {
            args: Prisma.videogamesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.videogamesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.videogamesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$videogamesPayload>
          }
          aggregate: {
            args: Prisma.VideogamesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVideogames>
          }
          groupBy: {
            args: Prisma.videogamesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VideogamesGroupByOutputType>[]
          }
          count: {
            args: Prisma.videogamesCountArgs<ExtArgs>,
            result: $Utils.Optional<VideogamesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type GroupsCountOutputType
   */

  export type GroupsCountOutputType = {
    groupmembers: number
  }

  export type GroupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupmembers?: boolean | GroupsCountOutputTypeCountGroupmembersArgs
  }

  // Custom InputTypes
  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsCountOutputType
     */
    select?: GroupsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeCountGroupmembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupmembersWhereInput
  }


  /**
   * Count Type ListsCountOutputType
   */

  export type ListsCountOutputType = {
    likes: number
    listitems: number
  }

  export type ListsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likes?: boolean | ListsCountOutputTypeCountLikesArgs
    listitems?: boolean | ListsCountOutputTypeCountListitemsArgs
  }

  // Custom InputTypes
  /**
   * ListsCountOutputType without action
   */
  export type ListsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListsCountOutputType
     */
    select?: ListsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ListsCountOutputType without action
   */
  export type ListsCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: likesWhereInput
  }

  /**
   * ListsCountOutputType without action
   */
  export type ListsCountOutputTypeCountListitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: listitemsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    follows_follows_followeremailTousers: number
    follows_follows_followingemailTousers: number
    groupmembers: number
    groups: number
    likes: number
    lists: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follows_follows_followeremailTousers?: boolean | UsersCountOutputTypeCountFollows_follows_followeremailTousersArgs
    follows_follows_followingemailTousers?: boolean | UsersCountOutputTypeCountFollows_follows_followingemailTousersArgs
    groupmembers?: boolean | UsersCountOutputTypeCountGroupmembersArgs
    groups?: boolean | UsersCountOutputTypeCountGroupsArgs
    likes?: boolean | UsersCountOutputTypeCountLikesArgs
    lists?: boolean | UsersCountOutputTypeCountListsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFollows_follows_followeremailTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: followsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFollows_follows_followingemailTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: followsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountGroupmembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupmembersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: likesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: listsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model anime
   */

  export type AggregateAnime = {
    _count: AnimeCountAggregateOutputType | null
    _avg: AnimeAvgAggregateOutputType | null
    _sum: AnimeSumAggregateOutputType | null
    _min: AnimeMinAggregateOutputType | null
    _max: AnimeMaxAggregateOutputType | null
  }

  export type AnimeAvgAggregateOutputType = {
    id: number | null
    numepisodes: number | null
  }

  export type AnimeSumAggregateOutputType = {
    id: number | null
    numepisodes: number | null
  }

  export type AnimeMinAggregateOutputType = {
    id: number | null
    title: string | null
    mediaimage: string | null
    numepisodes: number | null
    createdon: Date | null
  }

  export type AnimeMaxAggregateOutputType = {
    id: number | null
    title: string | null
    mediaimage: string | null
    numepisodes: number | null
    createdon: Date | null
  }

  export type AnimeCountAggregateOutputType = {
    id: number
    title: number
    mediaimage: number
    numepisodes: number
    createdon: number
    _all: number
  }


  export type AnimeAvgAggregateInputType = {
    id?: true
    numepisodes?: true
  }

  export type AnimeSumAggregateInputType = {
    id?: true
    numepisodes?: true
  }

  export type AnimeMinAggregateInputType = {
    id?: true
    title?: true
    mediaimage?: true
    numepisodes?: true
    createdon?: true
  }

  export type AnimeMaxAggregateInputType = {
    id?: true
    title?: true
    mediaimage?: true
    numepisodes?: true
    createdon?: true
  }

  export type AnimeCountAggregateInputType = {
    id?: true
    title?: true
    mediaimage?: true
    numepisodes?: true
    createdon?: true
    _all?: true
  }

  export type AnimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which anime to aggregate.
     */
    where?: animeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anime to fetch.
     */
    orderBy?: animeOrderByWithRelationInput | animeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: animeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anime from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anime.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned anime
    **/
    _count?: true | AnimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnimeMaxAggregateInputType
  }

  export type GetAnimeAggregateType<T extends AnimeAggregateArgs> = {
        [P in keyof T & keyof AggregateAnime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnime[P]>
      : GetScalarType<T[P], AggregateAnime[P]>
  }




  export type animeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: animeWhereInput
    orderBy?: animeOrderByWithAggregationInput | animeOrderByWithAggregationInput[]
    by: AnimeScalarFieldEnum[] | AnimeScalarFieldEnum
    having?: animeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnimeCountAggregateInputType | true
    _avg?: AnimeAvgAggregateInputType
    _sum?: AnimeSumAggregateInputType
    _min?: AnimeMinAggregateInputType
    _max?: AnimeMaxAggregateInputType
  }

  export type AnimeGroupByOutputType = {
    id: number
    title: string
    mediaimage: string | null
    numepisodes: number | null
    createdon: Date | null
    _count: AnimeCountAggregateOutputType | null
    _avg: AnimeAvgAggregateOutputType | null
    _sum: AnimeSumAggregateOutputType | null
    _min: AnimeMinAggregateOutputType | null
    _max: AnimeMaxAggregateOutputType | null
  }

  type GetAnimeGroupByPayload<T extends animeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnimeGroupByOutputType[P]>
            : GetScalarType<T[P], AnimeGroupByOutputType[P]>
        }
      >
    >


  export type animeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    mediaimage?: boolean
    numepisodes?: boolean
    createdon?: boolean
  }, ExtArgs["result"]["anime"]>

  export type animeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    mediaimage?: boolean
    numepisodes?: boolean
    createdon?: boolean
  }, ExtArgs["result"]["anime"]>

  export type animeSelectScalar = {
    id?: boolean
    title?: boolean
    mediaimage?: boolean
    numepisodes?: boolean
    createdon?: boolean
  }


  export type $animePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "anime"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      mediaimage: string | null
      numepisodes: number | null
      createdon: Date | null
    }, ExtArgs["result"]["anime"]>
    composites: {}
  }

  type animeGetPayload<S extends boolean | null | undefined | animeDefaultArgs> = $Result.GetResult<Prisma.$animePayload, S>

  type animeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<animeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnimeCountAggregateInputType | true
    }

  export interface animeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['anime'], meta: { name: 'anime' } }
    /**
     * Find zero or one Anime that matches the filter.
     * @param {animeFindUniqueArgs} args - Arguments to find a Anime
     * @example
     * // Get one Anime
     * const anime = await prisma.anime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends animeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, animeFindUniqueArgs<ExtArgs>>
    ): Prisma__animeClient<$Result.GetResult<Prisma.$animePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Anime that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {animeFindUniqueOrThrowArgs} args - Arguments to find a Anime
     * @example
     * // Get one Anime
     * const anime = await prisma.anime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends animeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, animeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__animeClient<$Result.GetResult<Prisma.$animePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Anime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animeFindFirstArgs} args - Arguments to find a Anime
     * @example
     * // Get one Anime
     * const anime = await prisma.anime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends animeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, animeFindFirstArgs<ExtArgs>>
    ): Prisma__animeClient<$Result.GetResult<Prisma.$animePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Anime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animeFindFirstOrThrowArgs} args - Arguments to find a Anime
     * @example
     * // Get one Anime
     * const anime = await prisma.anime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends animeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, animeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__animeClient<$Result.GetResult<Prisma.$animePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Anime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Anime
     * const anime = await prisma.anime.findMany()
     * 
     * // Get first 10 Anime
     * const anime = await prisma.anime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const animeWithIdOnly = await prisma.anime.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends animeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, animeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$animePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Anime.
     * @param {animeCreateArgs} args - Arguments to create a Anime.
     * @example
     * // Create one Anime
     * const Anime = await prisma.anime.create({
     *   data: {
     *     // ... data to create a Anime
     *   }
     * })
     * 
    **/
    create<T extends animeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, animeCreateArgs<ExtArgs>>
    ): Prisma__animeClient<$Result.GetResult<Prisma.$animePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Anime.
     * @param {animeCreateManyArgs} args - Arguments to create many Anime.
     * @example
     * // Create many Anime
     * const anime = await prisma.anime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends animeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, animeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Anime and returns the data saved in the database.
     * @param {animeCreateManyAndReturnArgs} args - Arguments to create many Anime.
     * @example
     * // Create many Anime
     * const anime = await prisma.anime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Anime and only return the `id`
     * const animeWithIdOnly = await prisma.anime.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends animeCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, animeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$animePayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Anime.
     * @param {animeDeleteArgs} args - Arguments to delete one Anime.
     * @example
     * // Delete one Anime
     * const Anime = await prisma.anime.delete({
     *   where: {
     *     // ... filter to delete one Anime
     *   }
     * })
     * 
    **/
    delete<T extends animeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, animeDeleteArgs<ExtArgs>>
    ): Prisma__animeClient<$Result.GetResult<Prisma.$animePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Anime.
     * @param {animeUpdateArgs} args - Arguments to update one Anime.
     * @example
     * // Update one Anime
     * const anime = await prisma.anime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends animeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, animeUpdateArgs<ExtArgs>>
    ): Prisma__animeClient<$Result.GetResult<Prisma.$animePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Anime.
     * @param {animeDeleteManyArgs} args - Arguments to filter Anime to delete.
     * @example
     * // Delete a few Anime
     * const { count } = await prisma.anime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends animeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, animeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Anime
     * const anime = await prisma.anime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends animeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, animeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Anime.
     * @param {animeUpsertArgs} args - Arguments to update or create a Anime.
     * @example
     * // Update or create a Anime
     * const anime = await prisma.anime.upsert({
     *   create: {
     *     // ... data to create a Anime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Anime we want to update
     *   }
     * })
    **/
    upsert<T extends animeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, animeUpsertArgs<ExtArgs>>
    ): Prisma__animeClient<$Result.GetResult<Prisma.$animePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Anime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animeCountArgs} args - Arguments to filter Anime to count.
     * @example
     * // Count the number of Anime
     * const count = await prisma.anime.count({
     *   where: {
     *     // ... the filter for the Anime we want to count
     *   }
     * })
    **/
    count<T extends animeCountArgs>(
      args?: Subset<T, animeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Anime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnimeAggregateArgs>(args: Subset<T, AnimeAggregateArgs>): Prisma.PrismaPromise<GetAnimeAggregateType<T>>

    /**
     * Group by Anime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {animeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends animeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: animeGroupByArgs['orderBy'] }
        : { orderBy?: animeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, animeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the anime model
   */
  readonly fields: animeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for anime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__animeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the anime model
   */ 
  interface animeFieldRefs {
    readonly id: FieldRef<"anime", 'Int'>
    readonly title: FieldRef<"anime", 'String'>
    readonly mediaimage: FieldRef<"anime", 'String'>
    readonly numepisodes: FieldRef<"anime", 'Int'>
    readonly createdon: FieldRef<"anime", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * anime findUnique
   */
  export type animeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anime
     */
    select?: animeSelect<ExtArgs> | null
    /**
     * Filter, which anime to fetch.
     */
    where: animeWhereUniqueInput
  }

  /**
   * anime findUniqueOrThrow
   */
  export type animeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anime
     */
    select?: animeSelect<ExtArgs> | null
    /**
     * Filter, which anime to fetch.
     */
    where: animeWhereUniqueInput
  }

  /**
   * anime findFirst
   */
  export type animeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anime
     */
    select?: animeSelect<ExtArgs> | null
    /**
     * Filter, which anime to fetch.
     */
    where?: animeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anime to fetch.
     */
    orderBy?: animeOrderByWithRelationInput | animeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anime.
     */
    cursor?: animeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anime from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anime.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anime.
     */
    distinct?: AnimeScalarFieldEnum | AnimeScalarFieldEnum[]
  }

  /**
   * anime findFirstOrThrow
   */
  export type animeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anime
     */
    select?: animeSelect<ExtArgs> | null
    /**
     * Filter, which anime to fetch.
     */
    where?: animeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anime to fetch.
     */
    orderBy?: animeOrderByWithRelationInput | animeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anime.
     */
    cursor?: animeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anime from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anime.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anime.
     */
    distinct?: AnimeScalarFieldEnum | AnimeScalarFieldEnum[]
  }

  /**
   * anime findMany
   */
  export type animeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anime
     */
    select?: animeSelect<ExtArgs> | null
    /**
     * Filter, which anime to fetch.
     */
    where?: animeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anime to fetch.
     */
    orderBy?: animeOrderByWithRelationInput | animeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing anime.
     */
    cursor?: animeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anime from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anime.
     */
    skip?: number
    distinct?: AnimeScalarFieldEnum | AnimeScalarFieldEnum[]
  }

  /**
   * anime create
   */
  export type animeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anime
     */
    select?: animeSelect<ExtArgs> | null
    /**
     * The data needed to create a anime.
     */
    data: XOR<animeCreateInput, animeUncheckedCreateInput>
  }

  /**
   * anime createMany
   */
  export type animeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many anime.
     */
    data: animeCreateManyInput | animeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * anime createManyAndReturn
   */
  export type animeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anime
     */
    select?: animeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many anime.
     */
    data: animeCreateManyInput | animeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * anime update
   */
  export type animeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anime
     */
    select?: animeSelect<ExtArgs> | null
    /**
     * The data needed to update a anime.
     */
    data: XOR<animeUpdateInput, animeUncheckedUpdateInput>
    /**
     * Choose, which anime to update.
     */
    where: animeWhereUniqueInput
  }

  /**
   * anime updateMany
   */
  export type animeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update anime.
     */
    data: XOR<animeUpdateManyMutationInput, animeUncheckedUpdateManyInput>
    /**
     * Filter which anime to update
     */
    where?: animeWhereInput
  }

  /**
   * anime upsert
   */
  export type animeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anime
     */
    select?: animeSelect<ExtArgs> | null
    /**
     * The filter to search for the anime to update in case it exists.
     */
    where: animeWhereUniqueInput
    /**
     * In case the anime found by the `where` argument doesn't exist, create a new anime with this data.
     */
    create: XOR<animeCreateInput, animeUncheckedCreateInput>
    /**
     * In case the anime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<animeUpdateInput, animeUncheckedUpdateInput>
  }

  /**
   * anime delete
   */
  export type animeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anime
     */
    select?: animeSelect<ExtArgs> | null
    /**
     * Filter which anime to delete.
     */
    where: animeWhereUniqueInput
  }

  /**
   * anime deleteMany
   */
  export type animeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which anime to delete
     */
    where?: animeWhereInput
  }

  /**
   * anime without action
   */
  export type animeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anime
     */
    select?: animeSelect<ExtArgs> | null
  }


  /**
   * Model follows
   */

  export type AggregateFollows = {
    _count: FollowsCountAggregateOutputType | null
    _min: FollowsMinAggregateOutputType | null
    _max: FollowsMaxAggregateOutputType | null
  }

  export type FollowsMinAggregateOutputType = {
    followeremail: string | null
    followingemail: string | null
  }

  export type FollowsMaxAggregateOutputType = {
    followeremail: string | null
    followingemail: string | null
  }

  export type FollowsCountAggregateOutputType = {
    followeremail: number
    followingemail: number
    _all: number
  }


  export type FollowsMinAggregateInputType = {
    followeremail?: true
    followingemail?: true
  }

  export type FollowsMaxAggregateInputType = {
    followeremail?: true
    followingemail?: true
  }

  export type FollowsCountAggregateInputType = {
    followeremail?: true
    followingemail?: true
    _all?: true
  }

  export type FollowsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which follows to aggregate.
     */
    where?: followsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of follows to fetch.
     */
    orderBy?: followsOrderByWithRelationInput | followsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: followsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned follows
    **/
    _count?: true | FollowsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowsMaxAggregateInputType
  }

  export type GetFollowsAggregateType<T extends FollowsAggregateArgs> = {
        [P in keyof T & keyof AggregateFollows]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollows[P]>
      : GetScalarType<T[P], AggregateFollows[P]>
  }




  export type followsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: followsWhereInput
    orderBy?: followsOrderByWithAggregationInput | followsOrderByWithAggregationInput[]
    by: FollowsScalarFieldEnum[] | FollowsScalarFieldEnum
    having?: followsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowsCountAggregateInputType | true
    _min?: FollowsMinAggregateInputType
    _max?: FollowsMaxAggregateInputType
  }

  export type FollowsGroupByOutputType = {
    followeremail: string
    followingemail: string
    _count: FollowsCountAggregateOutputType | null
    _min: FollowsMinAggregateOutputType | null
    _max: FollowsMaxAggregateOutputType | null
  }

  type GetFollowsGroupByPayload<T extends followsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowsGroupByOutputType[P]>
            : GetScalarType<T[P], FollowsGroupByOutputType[P]>
        }
      >
    >


  export type followsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    followeremail?: boolean
    followingemail?: boolean
    users_follows_followeremailTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_follows_followingemailTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follows"]>

  export type followsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    followeremail?: boolean
    followingemail?: boolean
    users_follows_followeremailTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_follows_followingemailTousers?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follows"]>

  export type followsSelectScalar = {
    followeremail?: boolean
    followingemail?: boolean
  }

  export type followsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_follows_followeremailTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_follows_followingemailTousers?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type followsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_follows_followeremailTousers?: boolean | usersDefaultArgs<ExtArgs>
    users_follows_followingemailTousers?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $followsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "follows"
    objects: {
      users_follows_followeremailTousers: Prisma.$usersPayload<ExtArgs>
      users_follows_followingemailTousers: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      followeremail: string
      followingemail: string
    }, ExtArgs["result"]["follows"]>
    composites: {}
  }

  type followsGetPayload<S extends boolean | null | undefined | followsDefaultArgs> = $Result.GetResult<Prisma.$followsPayload, S>

  type followsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<followsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FollowsCountAggregateInputType | true
    }

  export interface followsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['follows'], meta: { name: 'follows' } }
    /**
     * Find zero or one Follows that matches the filter.
     * @param {followsFindUniqueArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends followsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, followsFindUniqueArgs<ExtArgs>>
    ): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Follows that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {followsFindUniqueOrThrowArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends followsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, followsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followsFindFirstArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends followsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, followsFindFirstArgs<ExtArgs>>
    ): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Follows that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followsFindFirstOrThrowArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends followsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, followsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follows.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follows.findMany({ take: 10 })
     * 
     * // Only select the `followeremail`
     * const followsWithFolloweremailOnly = await prisma.follows.findMany({ select: { followeremail: true } })
     * 
    **/
    findMany<T extends followsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, followsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Follows.
     * @param {followsCreateArgs} args - Arguments to create a Follows.
     * @example
     * // Create one Follows
     * const Follows = await prisma.follows.create({
     *   data: {
     *     // ... data to create a Follows
     *   }
     * })
     * 
    **/
    create<T extends followsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, followsCreateArgs<ExtArgs>>
    ): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Follows.
     * @param {followsCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follows = await prisma.follows.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends followsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, followsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Follows and returns the data saved in the database.
     * @param {followsCreateManyAndReturnArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follows = await prisma.follows.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Follows and only return the `followeremail`
     * const followsWithFolloweremailOnly = await prisma.follows.createManyAndReturn({ 
     *   select: { followeremail: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends followsCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, followsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Follows.
     * @param {followsDeleteArgs} args - Arguments to delete one Follows.
     * @example
     * // Delete one Follows
     * const Follows = await prisma.follows.delete({
     *   where: {
     *     // ... filter to delete one Follows
     *   }
     * })
     * 
    **/
    delete<T extends followsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, followsDeleteArgs<ExtArgs>>
    ): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Follows.
     * @param {followsUpdateArgs} args - Arguments to update one Follows.
     * @example
     * // Update one Follows
     * const follows = await prisma.follows.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends followsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, followsUpdateArgs<ExtArgs>>
    ): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Follows.
     * @param {followsDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follows.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends followsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, followsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follows = await prisma.follows.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends followsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, followsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Follows.
     * @param {followsUpsertArgs} args - Arguments to update or create a Follows.
     * @example
     * // Update or create a Follows
     * const follows = await prisma.follows.upsert({
     *   create: {
     *     // ... data to create a Follows
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follows we want to update
     *   }
     * })
    **/
    upsert<T extends followsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, followsUpsertArgs<ExtArgs>>
    ): Prisma__followsClient<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followsCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follows.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends followsCountArgs>(
      args?: Subset<T, followsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowsAggregateArgs>(args: Subset<T, FollowsAggregateArgs>): Prisma.PrismaPromise<GetFollowsAggregateType<T>>

    /**
     * Group by Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends followsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: followsGroupByArgs['orderBy'] }
        : { orderBy?: followsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, followsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the follows model
   */
  readonly fields: followsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for follows.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__followsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users_follows_followeremailTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    users_follows_followingemailTousers<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the follows model
   */ 
  interface followsFieldRefs {
    readonly followeremail: FieldRef<"follows", 'String'>
    readonly followingemail: FieldRef<"follows", 'String'>
  }
    

  // Custom InputTypes
  /**
   * follows findUnique
   */
  export type followsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * Filter, which follows to fetch.
     */
    where: followsWhereUniqueInput
  }

  /**
   * follows findUniqueOrThrow
   */
  export type followsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * Filter, which follows to fetch.
     */
    where: followsWhereUniqueInput
  }

  /**
   * follows findFirst
   */
  export type followsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * Filter, which follows to fetch.
     */
    where?: followsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of follows to fetch.
     */
    orderBy?: followsOrderByWithRelationInput | followsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for follows.
     */
    cursor?: followsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of follows.
     */
    distinct?: FollowsScalarFieldEnum | FollowsScalarFieldEnum[]
  }

  /**
   * follows findFirstOrThrow
   */
  export type followsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * Filter, which follows to fetch.
     */
    where?: followsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of follows to fetch.
     */
    orderBy?: followsOrderByWithRelationInput | followsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for follows.
     */
    cursor?: followsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of follows.
     */
    distinct?: FollowsScalarFieldEnum | FollowsScalarFieldEnum[]
  }

  /**
   * follows findMany
   */
  export type followsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * Filter, which follows to fetch.
     */
    where?: followsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of follows to fetch.
     */
    orderBy?: followsOrderByWithRelationInput | followsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing follows.
     */
    cursor?: followsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` follows.
     */
    skip?: number
    distinct?: FollowsScalarFieldEnum | FollowsScalarFieldEnum[]
  }

  /**
   * follows create
   */
  export type followsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * The data needed to create a follows.
     */
    data: XOR<followsCreateInput, followsUncheckedCreateInput>
  }

  /**
   * follows createMany
   */
  export type followsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many follows.
     */
    data: followsCreateManyInput | followsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * follows createManyAndReturn
   */
  export type followsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many follows.
     */
    data: followsCreateManyInput | followsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * follows update
   */
  export type followsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * The data needed to update a follows.
     */
    data: XOR<followsUpdateInput, followsUncheckedUpdateInput>
    /**
     * Choose, which follows to update.
     */
    where: followsWhereUniqueInput
  }

  /**
   * follows updateMany
   */
  export type followsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update follows.
     */
    data: XOR<followsUpdateManyMutationInput, followsUncheckedUpdateManyInput>
    /**
     * Filter which follows to update
     */
    where?: followsWhereInput
  }

  /**
   * follows upsert
   */
  export type followsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * The filter to search for the follows to update in case it exists.
     */
    where: followsWhereUniqueInput
    /**
     * In case the follows found by the `where` argument doesn't exist, create a new follows with this data.
     */
    create: XOR<followsCreateInput, followsUncheckedCreateInput>
    /**
     * In case the follows was found with the provided `where` argument, update it with this data.
     */
    update: XOR<followsUpdateInput, followsUncheckedUpdateInput>
  }

  /**
   * follows delete
   */
  export type followsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    /**
     * Filter which follows to delete.
     */
    where: followsWhereUniqueInput
  }

  /**
   * follows deleteMany
   */
  export type followsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which follows to delete
     */
    where?: followsWhereInput
  }

  /**
   * follows without action
   */
  export type followsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
  }


  /**
   * Model groupmembers
   */

  export type AggregateGroupmembers = {
    _count: GroupmembersCountAggregateOutputType | null
    _avg: GroupmembersAvgAggregateOutputType | null
    _sum: GroupmembersSumAggregateOutputType | null
    _min: GroupmembersMinAggregateOutputType | null
    _max: GroupmembersMaxAggregateOutputType | null
  }

  export type GroupmembersAvgAggregateOutputType = {
    gid: number | null
  }

  export type GroupmembersSumAggregateOutputType = {
    gid: number | null
  }

  export type GroupmembersMinAggregateOutputType = {
    email: string | null
    gid: number | null
  }

  export type GroupmembersMaxAggregateOutputType = {
    email: string | null
    gid: number | null
  }

  export type GroupmembersCountAggregateOutputType = {
    email: number
    gid: number
    _all: number
  }


  export type GroupmembersAvgAggregateInputType = {
    gid?: true
  }

  export type GroupmembersSumAggregateInputType = {
    gid?: true
  }

  export type GroupmembersMinAggregateInputType = {
    email?: true
    gid?: true
  }

  export type GroupmembersMaxAggregateInputType = {
    email?: true
    gid?: true
  }

  export type GroupmembersCountAggregateInputType = {
    email?: true
    gid?: true
    _all?: true
  }

  export type GroupmembersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groupmembers to aggregate.
     */
    where?: groupmembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupmembers to fetch.
     */
    orderBy?: groupmembersOrderByWithRelationInput | groupmembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: groupmembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupmembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned groupmembers
    **/
    _count?: true | GroupmembersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupmembersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupmembersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupmembersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupmembersMaxAggregateInputType
  }

  export type GetGroupmembersAggregateType<T extends GroupmembersAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupmembers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupmembers[P]>
      : GetScalarType<T[P], AggregateGroupmembers[P]>
  }




  export type groupmembersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupmembersWhereInput
    orderBy?: groupmembersOrderByWithAggregationInput | groupmembersOrderByWithAggregationInput[]
    by: GroupmembersScalarFieldEnum[] | GroupmembersScalarFieldEnum
    having?: groupmembersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupmembersCountAggregateInputType | true
    _avg?: GroupmembersAvgAggregateInputType
    _sum?: GroupmembersSumAggregateInputType
    _min?: GroupmembersMinAggregateInputType
    _max?: GroupmembersMaxAggregateInputType
  }

  export type GroupmembersGroupByOutputType = {
    email: string
    gid: number
    _count: GroupmembersCountAggregateOutputType | null
    _avg: GroupmembersAvgAggregateOutputType | null
    _sum: GroupmembersSumAggregateOutputType | null
    _min: GroupmembersMinAggregateOutputType | null
    _max: GroupmembersMaxAggregateOutputType | null
  }

  type GetGroupmembersGroupByPayload<T extends groupmembersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupmembersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupmembersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupmembersGroupByOutputType[P]>
            : GetScalarType<T[P], GroupmembersGroupByOutputType[P]>
        }
      >
    >


  export type groupmembersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    gid?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    groups?: boolean | groupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupmembers"]>

  export type groupmembersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    gid?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    groups?: boolean | groupsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupmembers"]>

  export type groupmembersSelectScalar = {
    email?: boolean
    gid?: boolean
  }

  export type groupmembersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    groups?: boolean | groupsDefaultArgs<ExtArgs>
  }
  export type groupmembersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    groups?: boolean | groupsDefaultArgs<ExtArgs>
  }

  export type $groupmembersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "groupmembers"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      groups: Prisma.$groupsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      email: string
      gid: number
    }, ExtArgs["result"]["groupmembers"]>
    composites: {}
  }

  type groupmembersGetPayload<S extends boolean | null | undefined | groupmembersDefaultArgs> = $Result.GetResult<Prisma.$groupmembersPayload, S>

  type groupmembersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<groupmembersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupmembersCountAggregateInputType | true
    }

  export interface groupmembersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['groupmembers'], meta: { name: 'groupmembers' } }
    /**
     * Find zero or one Groupmembers that matches the filter.
     * @param {groupmembersFindUniqueArgs} args - Arguments to find a Groupmembers
     * @example
     * // Get one Groupmembers
     * const groupmembers = await prisma.groupmembers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends groupmembersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, groupmembersFindUniqueArgs<ExtArgs>>
    ): Prisma__groupmembersClient<$Result.GetResult<Prisma.$groupmembersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Groupmembers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {groupmembersFindUniqueOrThrowArgs} args - Arguments to find a Groupmembers
     * @example
     * // Get one Groupmembers
     * const groupmembers = await prisma.groupmembers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends groupmembersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, groupmembersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__groupmembersClient<$Result.GetResult<Prisma.$groupmembersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Groupmembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmembersFindFirstArgs} args - Arguments to find a Groupmembers
     * @example
     * // Get one Groupmembers
     * const groupmembers = await prisma.groupmembers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends groupmembersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, groupmembersFindFirstArgs<ExtArgs>>
    ): Prisma__groupmembersClient<$Result.GetResult<Prisma.$groupmembersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Groupmembers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmembersFindFirstOrThrowArgs} args - Arguments to find a Groupmembers
     * @example
     * // Get one Groupmembers
     * const groupmembers = await prisma.groupmembers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends groupmembersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, groupmembersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__groupmembersClient<$Result.GetResult<Prisma.$groupmembersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Groupmembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmembersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groupmembers
     * const groupmembers = await prisma.groupmembers.findMany()
     * 
     * // Get first 10 Groupmembers
     * const groupmembers = await prisma.groupmembers.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const groupmembersWithEmailOnly = await prisma.groupmembers.findMany({ select: { email: true } })
     * 
    **/
    findMany<T extends groupmembersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, groupmembersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupmembersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Groupmembers.
     * @param {groupmembersCreateArgs} args - Arguments to create a Groupmembers.
     * @example
     * // Create one Groupmembers
     * const Groupmembers = await prisma.groupmembers.create({
     *   data: {
     *     // ... data to create a Groupmembers
     *   }
     * })
     * 
    **/
    create<T extends groupmembersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, groupmembersCreateArgs<ExtArgs>>
    ): Prisma__groupmembersClient<$Result.GetResult<Prisma.$groupmembersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Groupmembers.
     * @param {groupmembersCreateManyArgs} args - Arguments to create many Groupmembers.
     * @example
     * // Create many Groupmembers
     * const groupmembers = await prisma.groupmembers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends groupmembersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, groupmembersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groupmembers and returns the data saved in the database.
     * @param {groupmembersCreateManyAndReturnArgs} args - Arguments to create many Groupmembers.
     * @example
     * // Create many Groupmembers
     * const groupmembers = await prisma.groupmembers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groupmembers and only return the `email`
     * const groupmembersWithEmailOnly = await prisma.groupmembers.createManyAndReturn({ 
     *   select: { email: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends groupmembersCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, groupmembersCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupmembersPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Groupmembers.
     * @param {groupmembersDeleteArgs} args - Arguments to delete one Groupmembers.
     * @example
     * // Delete one Groupmembers
     * const Groupmembers = await prisma.groupmembers.delete({
     *   where: {
     *     // ... filter to delete one Groupmembers
     *   }
     * })
     * 
    **/
    delete<T extends groupmembersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, groupmembersDeleteArgs<ExtArgs>>
    ): Prisma__groupmembersClient<$Result.GetResult<Prisma.$groupmembersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Groupmembers.
     * @param {groupmembersUpdateArgs} args - Arguments to update one Groupmembers.
     * @example
     * // Update one Groupmembers
     * const groupmembers = await prisma.groupmembers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends groupmembersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, groupmembersUpdateArgs<ExtArgs>>
    ): Prisma__groupmembersClient<$Result.GetResult<Prisma.$groupmembersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Groupmembers.
     * @param {groupmembersDeleteManyArgs} args - Arguments to filter Groupmembers to delete.
     * @example
     * // Delete a few Groupmembers
     * const { count } = await prisma.groupmembers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends groupmembersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, groupmembersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groupmembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmembersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groupmembers
     * const groupmembers = await prisma.groupmembers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends groupmembersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, groupmembersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Groupmembers.
     * @param {groupmembersUpsertArgs} args - Arguments to update or create a Groupmembers.
     * @example
     * // Update or create a Groupmembers
     * const groupmembers = await prisma.groupmembers.upsert({
     *   create: {
     *     // ... data to create a Groupmembers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Groupmembers we want to update
     *   }
     * })
    **/
    upsert<T extends groupmembersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, groupmembersUpsertArgs<ExtArgs>>
    ): Prisma__groupmembersClient<$Result.GetResult<Prisma.$groupmembersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Groupmembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmembersCountArgs} args - Arguments to filter Groupmembers to count.
     * @example
     * // Count the number of Groupmembers
     * const count = await prisma.groupmembers.count({
     *   where: {
     *     // ... the filter for the Groupmembers we want to count
     *   }
     * })
    **/
    count<T extends groupmembersCountArgs>(
      args?: Subset<T, groupmembersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupmembersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Groupmembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupmembersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupmembersAggregateArgs>(args: Subset<T, GroupmembersAggregateArgs>): Prisma.PrismaPromise<GetGroupmembersAggregateType<T>>

    /**
     * Group by Groupmembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupmembersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends groupmembersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: groupmembersGroupByArgs['orderBy'] }
        : { orderBy?: groupmembersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, groupmembersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupmembersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the groupmembers model
   */
  readonly fields: groupmembersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for groupmembers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__groupmembersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    groups<T extends groupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, groupsDefaultArgs<ExtArgs>>): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the groupmembers model
   */ 
  interface groupmembersFieldRefs {
    readonly email: FieldRef<"groupmembers", 'String'>
    readonly gid: FieldRef<"groupmembers", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * groupmembers findUnique
   */
  export type groupmembersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmembers
     */
    select?: groupmembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmembersInclude<ExtArgs> | null
    /**
     * Filter, which groupmembers to fetch.
     */
    where: groupmembersWhereUniqueInput
  }

  /**
   * groupmembers findUniqueOrThrow
   */
  export type groupmembersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmembers
     */
    select?: groupmembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmembersInclude<ExtArgs> | null
    /**
     * Filter, which groupmembers to fetch.
     */
    where: groupmembersWhereUniqueInput
  }

  /**
   * groupmembers findFirst
   */
  export type groupmembersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmembers
     */
    select?: groupmembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmembersInclude<ExtArgs> | null
    /**
     * Filter, which groupmembers to fetch.
     */
    where?: groupmembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupmembers to fetch.
     */
    orderBy?: groupmembersOrderByWithRelationInput | groupmembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groupmembers.
     */
    cursor?: groupmembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupmembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groupmembers.
     */
    distinct?: GroupmembersScalarFieldEnum | GroupmembersScalarFieldEnum[]
  }

  /**
   * groupmembers findFirstOrThrow
   */
  export type groupmembersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmembers
     */
    select?: groupmembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmembersInclude<ExtArgs> | null
    /**
     * Filter, which groupmembers to fetch.
     */
    where?: groupmembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupmembers to fetch.
     */
    orderBy?: groupmembersOrderByWithRelationInput | groupmembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groupmembers.
     */
    cursor?: groupmembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupmembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groupmembers.
     */
    distinct?: GroupmembersScalarFieldEnum | GroupmembersScalarFieldEnum[]
  }

  /**
   * groupmembers findMany
   */
  export type groupmembersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmembers
     */
    select?: groupmembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmembersInclude<ExtArgs> | null
    /**
     * Filter, which groupmembers to fetch.
     */
    where?: groupmembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groupmembers to fetch.
     */
    orderBy?: groupmembersOrderByWithRelationInput | groupmembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing groupmembers.
     */
    cursor?: groupmembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groupmembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groupmembers.
     */
    skip?: number
    distinct?: GroupmembersScalarFieldEnum | GroupmembersScalarFieldEnum[]
  }

  /**
   * groupmembers create
   */
  export type groupmembersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmembers
     */
    select?: groupmembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmembersInclude<ExtArgs> | null
    /**
     * The data needed to create a groupmembers.
     */
    data: XOR<groupmembersCreateInput, groupmembersUncheckedCreateInput>
  }

  /**
   * groupmembers createMany
   */
  export type groupmembersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many groupmembers.
     */
    data: groupmembersCreateManyInput | groupmembersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * groupmembers createManyAndReturn
   */
  export type groupmembersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmembers
     */
    select?: groupmembersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many groupmembers.
     */
    data: groupmembersCreateManyInput | groupmembersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmembersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * groupmembers update
   */
  export type groupmembersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmembers
     */
    select?: groupmembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmembersInclude<ExtArgs> | null
    /**
     * The data needed to update a groupmembers.
     */
    data: XOR<groupmembersUpdateInput, groupmembersUncheckedUpdateInput>
    /**
     * Choose, which groupmembers to update.
     */
    where: groupmembersWhereUniqueInput
  }

  /**
   * groupmembers updateMany
   */
  export type groupmembersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update groupmembers.
     */
    data: XOR<groupmembersUpdateManyMutationInput, groupmembersUncheckedUpdateManyInput>
    /**
     * Filter which groupmembers to update
     */
    where?: groupmembersWhereInput
  }

  /**
   * groupmembers upsert
   */
  export type groupmembersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmembers
     */
    select?: groupmembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmembersInclude<ExtArgs> | null
    /**
     * The filter to search for the groupmembers to update in case it exists.
     */
    where: groupmembersWhereUniqueInput
    /**
     * In case the groupmembers found by the `where` argument doesn't exist, create a new groupmembers with this data.
     */
    create: XOR<groupmembersCreateInput, groupmembersUncheckedCreateInput>
    /**
     * In case the groupmembers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<groupmembersUpdateInput, groupmembersUncheckedUpdateInput>
  }

  /**
   * groupmembers delete
   */
  export type groupmembersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmembers
     */
    select?: groupmembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmembersInclude<ExtArgs> | null
    /**
     * Filter which groupmembers to delete.
     */
    where: groupmembersWhereUniqueInput
  }

  /**
   * groupmembers deleteMany
   */
  export type groupmembersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groupmembers to delete
     */
    where?: groupmembersWhereInput
  }

  /**
   * groupmembers without action
   */
  export type groupmembersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmembers
     */
    select?: groupmembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmembersInclude<ExtArgs> | null
  }


  /**
   * Model groups
   */

  export type AggregateGroups = {
    _count: GroupsCountAggregateOutputType | null
    _avg: GroupsAvgAggregateOutputType | null
    _sum: GroupsSumAggregateOutputType | null
    _min: GroupsMinAggregateOutputType | null
    _max: GroupsMaxAggregateOutputType | null
  }

  export type GroupsAvgAggregateOutputType = {
    gid: number | null
  }

  export type GroupsSumAggregateOutputType = {
    gid: number | null
  }

  export type GroupsMinAggregateOutputType = {
    gid: number | null
    groupname: string | null
    ownedby: string | null
  }

  export type GroupsMaxAggregateOutputType = {
    gid: number | null
    groupname: string | null
    ownedby: string | null
  }

  export type GroupsCountAggregateOutputType = {
    gid: number
    groupname: number
    ownedby: number
    _all: number
  }


  export type GroupsAvgAggregateInputType = {
    gid?: true
  }

  export type GroupsSumAggregateInputType = {
    gid?: true
  }

  export type GroupsMinAggregateInputType = {
    gid?: true
    groupname?: true
    ownedby?: true
  }

  export type GroupsMaxAggregateInputType = {
    gid?: true
    groupname?: true
    ownedby?: true
  }

  export type GroupsCountAggregateInputType = {
    gid?: true
    groupname?: true
    ownedby?: true
    _all?: true
  }

  export type GroupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groups to aggregate.
     */
    where?: groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupsOrderByWithRelationInput | groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned groups
    **/
    _count?: true | GroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupsMaxAggregateInputType
  }

  export type GetGroupsAggregateType<T extends GroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroups[P]>
      : GetScalarType<T[P], AggregateGroups[P]>
  }




  export type groupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupsWhereInput
    orderBy?: groupsOrderByWithAggregationInput | groupsOrderByWithAggregationInput[]
    by: GroupsScalarFieldEnum[] | GroupsScalarFieldEnum
    having?: groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupsCountAggregateInputType | true
    _avg?: GroupsAvgAggregateInputType
    _sum?: GroupsSumAggregateInputType
    _min?: GroupsMinAggregateInputType
    _max?: GroupsMaxAggregateInputType
  }

  export type GroupsGroupByOutputType = {
    gid: number
    groupname: string
    ownedby: string
    _count: GroupsCountAggregateOutputType | null
    _avg: GroupsAvgAggregateOutputType | null
    _sum: GroupsSumAggregateOutputType | null
    _min: GroupsMinAggregateOutputType | null
    _max: GroupsMaxAggregateOutputType | null
  }

  type GetGroupsGroupByPayload<T extends groupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupsGroupByOutputType[P]>
            : GetScalarType<T[P], GroupsGroupByOutputType[P]>
        }
      >
    >


  export type groupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    gid?: boolean
    groupname?: boolean
    ownedby?: boolean
    groupmembers?: boolean | groups$groupmembersArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | GroupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groups"]>

  export type groupsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    gid?: boolean
    groupname?: boolean
    ownedby?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groups"]>

  export type groupsSelectScalar = {
    gid?: boolean
    groupname?: boolean
    ownedby?: boolean
  }

  export type groupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupmembers?: boolean | groups$groupmembersArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | GroupsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type groupsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $groupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "groups"
    objects: {
      groupmembers: Prisma.$groupmembersPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      gid: number
      groupname: string
      ownedby: string
    }, ExtArgs["result"]["groups"]>
    composites: {}
  }

  type groupsGetPayload<S extends boolean | null | undefined | groupsDefaultArgs> = $Result.GetResult<Prisma.$groupsPayload, S>

  type groupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<groupsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupsCountAggregateInputType | true
    }

  export interface groupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['groups'], meta: { name: 'groups' } }
    /**
     * Find zero or one Groups that matches the filter.
     * @param {groupsFindUniqueArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends groupsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, groupsFindUniqueArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Groups that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {groupsFindUniqueOrThrowArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends groupsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, groupsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsFindFirstArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends groupsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, groupsFindFirstArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsFindFirstOrThrowArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends groupsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, groupsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.groups.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.groups.findMany({ take: 10 })
     * 
     * // Only select the `gid`
     * const groupsWithGidOnly = await prisma.groups.findMany({ select: { gid: true } })
     * 
    **/
    findMany<T extends groupsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, groupsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Groups.
     * @param {groupsCreateArgs} args - Arguments to create a Groups.
     * @example
     * // Create one Groups
     * const Groups = await prisma.groups.create({
     *   data: {
     *     // ... data to create a Groups
     *   }
     * })
     * 
    **/
    create<T extends groupsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, groupsCreateArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Groups.
     * @param {groupsCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const groups = await prisma.groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends groupsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, groupsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {groupsCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const groups = await prisma.groups.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `gid`
     * const groupsWithGidOnly = await prisma.groups.createManyAndReturn({ 
     *   select: { gid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends groupsCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, groupsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Groups.
     * @param {groupsDeleteArgs} args - Arguments to delete one Groups.
     * @example
     * // Delete one Groups
     * const Groups = await prisma.groups.delete({
     *   where: {
     *     // ... filter to delete one Groups
     *   }
     * })
     * 
    **/
    delete<T extends groupsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, groupsDeleteArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Groups.
     * @param {groupsUpdateArgs} args - Arguments to update one Groups.
     * @example
     * // Update one Groups
     * const groups = await prisma.groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends groupsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, groupsUpdateArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Groups.
     * @param {groupsDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends groupsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, groupsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const groups = await prisma.groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends groupsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, groupsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Groups.
     * @param {groupsUpsertArgs} args - Arguments to update or create a Groups.
     * @example
     * // Update or create a Groups
     * const groups = await prisma.groups.upsert({
     *   create: {
     *     // ... data to create a Groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Groups we want to update
     *   }
     * })
    **/
    upsert<T extends groupsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, groupsUpsertArgs<ExtArgs>>
    ): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.groups.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends groupsCountArgs>(
      args?: Subset<T, groupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupsAggregateArgs>(args: Subset<T, GroupsAggregateArgs>): Prisma.PrismaPromise<GetGroupsAggregateType<T>>

    /**
     * Group by Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: groupsGroupByArgs['orderBy'] }
        : { orderBy?: groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the groups model
   */
  readonly fields: groupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__groupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    groupmembers<T extends groups$groupmembersArgs<ExtArgs> = {}>(args?: Subset<T, groups$groupmembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupmembersPayload<ExtArgs>, T, 'findMany'> | Null>;

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the groups model
   */ 
  interface groupsFieldRefs {
    readonly gid: FieldRef<"groups", 'Int'>
    readonly groupname: FieldRef<"groups", 'String'>
    readonly ownedby: FieldRef<"groups", 'String'>
  }
    

  // Custom InputTypes
  /**
   * groups findUnique
   */
  export type groupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where: groupsWhereUniqueInput
  }

  /**
   * groups findUniqueOrThrow
   */
  export type groupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where: groupsWhereUniqueInput
  }

  /**
   * groups findFirst
   */
  export type groupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where?: groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupsOrderByWithRelationInput | groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups.
     */
    cursor?: groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups.
     */
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * groups findFirstOrThrow
   */
  export type groupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where?: groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupsOrderByWithRelationInput | groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups.
     */
    cursor?: groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups.
     */
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * groups findMany
   */
  export type groupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where?: groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupsOrderByWithRelationInput | groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing groups.
     */
    cursor?: groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * groups create
   */
  export type groupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * The data needed to create a groups.
     */
    data: XOR<groupsCreateInput, groupsUncheckedCreateInput>
  }

  /**
   * groups createMany
   */
  export type groupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many groups.
     */
    data: groupsCreateManyInput | groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * groups createManyAndReturn
   */
  export type groupsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many groups.
     */
    data: groupsCreateManyInput | groupsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * groups update
   */
  export type groupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * The data needed to update a groups.
     */
    data: XOR<groupsUpdateInput, groupsUncheckedUpdateInput>
    /**
     * Choose, which groups to update.
     */
    where: groupsWhereUniqueInput
  }

  /**
   * groups updateMany
   */
  export type groupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update groups.
     */
    data: XOR<groupsUpdateManyMutationInput, groupsUncheckedUpdateManyInput>
    /**
     * Filter which groups to update
     */
    where?: groupsWhereInput
  }

  /**
   * groups upsert
   */
  export type groupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * The filter to search for the groups to update in case it exists.
     */
    where: groupsWhereUniqueInput
    /**
     * In case the groups found by the `where` argument doesn't exist, create a new groups with this data.
     */
    create: XOR<groupsCreateInput, groupsUncheckedCreateInput>
    /**
     * In case the groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<groupsUpdateInput, groupsUncheckedUpdateInput>
  }

  /**
   * groups delete
   */
  export type groupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupsInclude<ExtArgs> | null
    /**
     * Filter which groups to delete.
     */
    where: groupsWhereUniqueInput
  }

  /**
   * groups deleteMany
   */
  export type groupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groups to delete
     */
    where?: groupsWhereInput
  }

  /**
   * groups.groupmembers
   */
  export type groups$groupmembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmembers
     */
    select?: groupmembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmembersInclude<ExtArgs> | null
    where?: groupmembersWhereInput
    orderBy?: groupmembersOrderByWithRelationInput | groupmembersOrderByWithRelationInput[]
    cursor?: groupmembersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupmembersScalarFieldEnum | GroupmembersScalarFieldEnum[]
  }

  /**
   * groups without action
   */
  export type groupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupsInclude<ExtArgs> | null
  }


  /**
   * Model likes
   */

  export type AggregateLikes = {
    _count: LikesCountAggregateOutputType | null
    _min: LikesMinAggregateOutputType | null
    _max: LikesMaxAggregateOutputType | null
  }

  export type LikesMinAggregateOutputType = {
    likeremail: string | null
    likingemail: string | null
    listname: string | null
  }

  export type LikesMaxAggregateOutputType = {
    likeremail: string | null
    likingemail: string | null
    listname: string | null
  }

  export type LikesCountAggregateOutputType = {
    likeremail: number
    likingemail: number
    listname: number
    _all: number
  }


  export type LikesMinAggregateInputType = {
    likeremail?: true
    likingemail?: true
    listname?: true
  }

  export type LikesMaxAggregateInputType = {
    likeremail?: true
    likingemail?: true
    listname?: true
  }

  export type LikesCountAggregateInputType = {
    likeremail?: true
    likingemail?: true
    listname?: true
    _all?: true
  }

  export type LikesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which likes to aggregate.
     */
    where?: likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of likes to fetch.
     */
    orderBy?: likesOrderByWithRelationInput | likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned likes
    **/
    _count?: true | LikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikesMaxAggregateInputType
  }

  export type GetLikesAggregateType<T extends LikesAggregateArgs> = {
        [P in keyof T & keyof AggregateLikes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLikes[P]>
      : GetScalarType<T[P], AggregateLikes[P]>
  }




  export type likesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: likesWhereInput
    orderBy?: likesOrderByWithAggregationInput | likesOrderByWithAggregationInput[]
    by: LikesScalarFieldEnum[] | LikesScalarFieldEnum
    having?: likesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikesCountAggregateInputType | true
    _min?: LikesMinAggregateInputType
    _max?: LikesMaxAggregateInputType
  }

  export type LikesGroupByOutputType = {
    likeremail: string
    likingemail: string
    listname: string
    _count: LikesCountAggregateOutputType | null
    _min: LikesMinAggregateOutputType | null
    _max: LikesMaxAggregateOutputType | null
  }

  type GetLikesGroupByPayload<T extends likesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LikesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikesGroupByOutputType[P]>
            : GetScalarType<T[P], LikesGroupByOutputType[P]>
        }
      >
    >


  export type likesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    likeremail?: boolean
    likingemail?: boolean
    listname?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    listitems?: boolean | listsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likes"]>

  export type likesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    likeremail?: boolean
    likingemail?: boolean
    listname?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    listitems?: boolean | listsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["likes"]>

  export type likesSelectScalar = {
    likeremail?: boolean
    likingemail?: boolean
    listname?: boolean
  }

  export type likesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    listitems?: boolean | listsDefaultArgs<ExtArgs>
  }
  export type likesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    listitems?: boolean | listsDefaultArgs<ExtArgs>
  }

  export type $likesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "likes"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      listitems: Prisma.$listsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      likeremail: string
      likingemail: string
      listname: string
    }, ExtArgs["result"]["likes"]>
    composites: {}
  }

  type likesGetPayload<S extends boolean | null | undefined | likesDefaultArgs> = $Result.GetResult<Prisma.$likesPayload, S>

  type likesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<likesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LikesCountAggregateInputType | true
    }

  export interface likesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['likes'], meta: { name: 'likes' } }
    /**
     * Find zero or one Likes that matches the filter.
     * @param {likesFindUniqueArgs} args - Arguments to find a Likes
     * @example
     * // Get one Likes
     * const likes = await prisma.likes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends likesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, likesFindUniqueArgs<ExtArgs>>
    ): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Likes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {likesFindUniqueOrThrowArgs} args - Arguments to find a Likes
     * @example
     * // Get one Likes
     * const likes = await prisma.likes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends likesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, likesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {likesFindFirstArgs} args - Arguments to find a Likes
     * @example
     * // Get one Likes
     * const likes = await prisma.likes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends likesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, likesFindFirstArgs<ExtArgs>>
    ): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Likes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {likesFindFirstOrThrowArgs} args - Arguments to find a Likes
     * @example
     * // Get one Likes
     * const likes = await prisma.likes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends likesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, likesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {likesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.likes.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.likes.findMany({ take: 10 })
     * 
     * // Only select the `likeremail`
     * const likesWithLikeremailOnly = await prisma.likes.findMany({ select: { likeremail: true } })
     * 
    **/
    findMany<T extends likesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, likesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Likes.
     * @param {likesCreateArgs} args - Arguments to create a Likes.
     * @example
     * // Create one Likes
     * const Likes = await prisma.likes.create({
     *   data: {
     *     // ... data to create a Likes
     *   }
     * })
     * 
    **/
    create<T extends likesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, likesCreateArgs<ExtArgs>>
    ): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Likes.
     * @param {likesCreateManyArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const likes = await prisma.likes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends likesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, likesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Likes and returns the data saved in the database.
     * @param {likesCreateManyAndReturnArgs} args - Arguments to create many Likes.
     * @example
     * // Create many Likes
     * const likes = await prisma.likes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Likes and only return the `likeremail`
     * const likesWithLikeremailOnly = await prisma.likes.createManyAndReturn({ 
     *   select: { likeremail: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends likesCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, likesCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Likes.
     * @param {likesDeleteArgs} args - Arguments to delete one Likes.
     * @example
     * // Delete one Likes
     * const Likes = await prisma.likes.delete({
     *   where: {
     *     // ... filter to delete one Likes
     *   }
     * })
     * 
    **/
    delete<T extends likesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, likesDeleteArgs<ExtArgs>>
    ): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Likes.
     * @param {likesUpdateArgs} args - Arguments to update one Likes.
     * @example
     * // Update one Likes
     * const likes = await prisma.likes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends likesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, likesUpdateArgs<ExtArgs>>
    ): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Likes.
     * @param {likesDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.likes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends likesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, likesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {likesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const likes = await prisma.likes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends likesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, likesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Likes.
     * @param {likesUpsertArgs} args - Arguments to update or create a Likes.
     * @example
     * // Update or create a Likes
     * const likes = await prisma.likes.upsert({
     *   create: {
     *     // ... data to create a Likes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Likes we want to update
     *   }
     * })
    **/
    upsert<T extends likesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, likesUpsertArgs<ExtArgs>>
    ): Prisma__likesClient<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {likesCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.likes.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends likesCountArgs>(
      args?: Subset<T, likesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikesAggregateArgs>(args: Subset<T, LikesAggregateArgs>): Prisma.PrismaPromise<GetLikesAggregateType<T>>

    /**
     * Group by Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {likesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends likesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: likesGroupByArgs['orderBy'] }
        : { orderBy?: likesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, likesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the likes model
   */
  readonly fields: likesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for likes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__likesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    listitems<T extends listsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, listsDefaultArgs<ExtArgs>>): Prisma__listsClient<$Result.GetResult<Prisma.$listsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the likes model
   */ 
  interface likesFieldRefs {
    readonly likeremail: FieldRef<"likes", 'String'>
    readonly likingemail: FieldRef<"likes", 'String'>
    readonly listname: FieldRef<"likes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * likes findUnique
   */
  export type likesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * Filter, which likes to fetch.
     */
    where: likesWhereUniqueInput
  }

  /**
   * likes findUniqueOrThrow
   */
  export type likesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * Filter, which likes to fetch.
     */
    where: likesWhereUniqueInput
  }

  /**
   * likes findFirst
   */
  export type likesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * Filter, which likes to fetch.
     */
    where?: likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of likes to fetch.
     */
    orderBy?: likesOrderByWithRelationInput | likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for likes.
     */
    cursor?: likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of likes.
     */
    distinct?: LikesScalarFieldEnum | LikesScalarFieldEnum[]
  }

  /**
   * likes findFirstOrThrow
   */
  export type likesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * Filter, which likes to fetch.
     */
    where?: likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of likes to fetch.
     */
    orderBy?: likesOrderByWithRelationInput | likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for likes.
     */
    cursor?: likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of likes.
     */
    distinct?: LikesScalarFieldEnum | LikesScalarFieldEnum[]
  }

  /**
   * likes findMany
   */
  export type likesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * Filter, which likes to fetch.
     */
    where?: likesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of likes to fetch.
     */
    orderBy?: likesOrderByWithRelationInput | likesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing likes.
     */
    cursor?: likesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` likes.
     */
    skip?: number
    distinct?: LikesScalarFieldEnum | LikesScalarFieldEnum[]
  }

  /**
   * likes create
   */
  export type likesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * The data needed to create a likes.
     */
    data: XOR<likesCreateInput, likesUncheckedCreateInput>
  }

  /**
   * likes createMany
   */
  export type likesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many likes.
     */
    data: likesCreateManyInput | likesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * likes createManyAndReturn
   */
  export type likesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many likes.
     */
    data: likesCreateManyInput | likesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * likes update
   */
  export type likesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * The data needed to update a likes.
     */
    data: XOR<likesUpdateInput, likesUncheckedUpdateInput>
    /**
     * Choose, which likes to update.
     */
    where: likesWhereUniqueInput
  }

  /**
   * likes updateMany
   */
  export type likesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update likes.
     */
    data: XOR<likesUpdateManyMutationInput, likesUncheckedUpdateManyInput>
    /**
     * Filter which likes to update
     */
    where?: likesWhereInput
  }

  /**
   * likes upsert
   */
  export type likesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * The filter to search for the likes to update in case it exists.
     */
    where: likesWhereUniqueInput
    /**
     * In case the likes found by the `where` argument doesn't exist, create a new likes with this data.
     */
    create: XOR<likesCreateInput, likesUncheckedCreateInput>
    /**
     * In case the likes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<likesUpdateInput, likesUncheckedUpdateInput>
  }

  /**
   * likes delete
   */
  export type likesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    /**
     * Filter which likes to delete.
     */
    where: likesWhereUniqueInput
  }

  /**
   * likes deleteMany
   */
  export type likesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which likes to delete
     */
    where?: likesWhereInput
  }

  /**
   * likes without action
   */
  export type likesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
  }


  /**
   * Model listitems
   */

  export type AggregateListitems = {
    _count: ListitemsCountAggregateOutputType | null
    _avg: ListitemsAvgAggregateOutputType | null
    _sum: ListitemsSumAggregateOutputType | null
    _min: ListitemsMinAggregateOutputType | null
    _max: ListitemsMaxAggregateOutputType | null
  }

  export type ListitemsAvgAggregateOutputType = {
    rankinginlist: number | null
    itemid: number | null
  }

  export type ListitemsSumAggregateOutputType = {
    rankinginlist: number | null
    itemid: number | null
  }

  export type ListitemsMinAggregateOutputType = {
    email: string | null
    listname: string | null
    rankinginlist: number | null
    itemid: number | null
  }

  export type ListitemsMaxAggregateOutputType = {
    email: string | null
    listname: string | null
    rankinginlist: number | null
    itemid: number | null
  }

  export type ListitemsCountAggregateOutputType = {
    email: number
    listname: number
    rankinginlist: number
    itemid: number
    _all: number
  }


  export type ListitemsAvgAggregateInputType = {
    rankinginlist?: true
    itemid?: true
  }

  export type ListitemsSumAggregateInputType = {
    rankinginlist?: true
    itemid?: true
  }

  export type ListitemsMinAggregateInputType = {
    email?: true
    listname?: true
    rankinginlist?: true
    itemid?: true
  }

  export type ListitemsMaxAggregateInputType = {
    email?: true
    listname?: true
    rankinginlist?: true
    itemid?: true
  }

  export type ListitemsCountAggregateInputType = {
    email?: true
    listname?: true
    rankinginlist?: true
    itemid?: true
    _all?: true
  }

  export type ListitemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which listitems to aggregate.
     */
    where?: listitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listitems to fetch.
     */
    orderBy?: listitemsOrderByWithRelationInput | listitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: listitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned listitems
    **/
    _count?: true | ListitemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListitemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListitemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListitemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListitemsMaxAggregateInputType
  }

  export type GetListitemsAggregateType<T extends ListitemsAggregateArgs> = {
        [P in keyof T & keyof AggregateListitems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListitems[P]>
      : GetScalarType<T[P], AggregateListitems[P]>
  }




  export type listitemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: listitemsWhereInput
    orderBy?: listitemsOrderByWithAggregationInput | listitemsOrderByWithAggregationInput[]
    by: ListitemsScalarFieldEnum[] | ListitemsScalarFieldEnum
    having?: listitemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListitemsCountAggregateInputType | true
    _avg?: ListitemsAvgAggregateInputType
    _sum?: ListitemsSumAggregateInputType
    _min?: ListitemsMinAggregateInputType
    _max?: ListitemsMaxAggregateInputType
  }

  export type ListitemsGroupByOutputType = {
    email: string
    listname: string
    rankinginlist: number
    itemid: number
    _count: ListitemsCountAggregateOutputType | null
    _avg: ListitemsAvgAggregateOutputType | null
    _sum: ListitemsSumAggregateOutputType | null
    _min: ListitemsMinAggregateOutputType | null
    _max: ListitemsMaxAggregateOutputType | null
  }

  type GetListitemsGroupByPayload<T extends listitemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListitemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListitemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListitemsGroupByOutputType[P]>
            : GetScalarType<T[P], ListitemsGroupByOutputType[P]>
        }
      >
    >


  export type listitemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    listname?: boolean
    rankinginlist?: boolean
    itemid?: boolean
    lists?: boolean | listsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listitems"]>

  export type listitemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    listname?: boolean
    rankinginlist?: boolean
    itemid?: boolean
    lists?: boolean | listsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listitems"]>

  export type listitemsSelectScalar = {
    email?: boolean
    listname?: boolean
    rankinginlist?: boolean
    itemid?: boolean
  }

  export type listitemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lists?: boolean | listsDefaultArgs<ExtArgs>
  }
  export type listitemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lists?: boolean | listsDefaultArgs<ExtArgs>
  }

  export type $listitemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "listitems"
    objects: {
      lists: Prisma.$listsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      email: string
      listname: string
      rankinginlist: number
      itemid: number
    }, ExtArgs["result"]["listitems"]>
    composites: {}
  }

  type listitemsGetPayload<S extends boolean | null | undefined | listitemsDefaultArgs> = $Result.GetResult<Prisma.$listitemsPayload, S>

  type listitemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<listitemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ListitemsCountAggregateInputType | true
    }

  export interface listitemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['listitems'], meta: { name: 'listitems' } }
    /**
     * Find zero or one Listitems that matches the filter.
     * @param {listitemsFindUniqueArgs} args - Arguments to find a Listitems
     * @example
     * // Get one Listitems
     * const listitems = await prisma.listitems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends listitemsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, listitemsFindUniqueArgs<ExtArgs>>
    ): Prisma__listitemsClient<$Result.GetResult<Prisma.$listitemsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Listitems that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {listitemsFindUniqueOrThrowArgs} args - Arguments to find a Listitems
     * @example
     * // Get one Listitems
     * const listitems = await prisma.listitems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends listitemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, listitemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__listitemsClient<$Result.GetResult<Prisma.$listitemsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Listitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listitemsFindFirstArgs} args - Arguments to find a Listitems
     * @example
     * // Get one Listitems
     * const listitems = await prisma.listitems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends listitemsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, listitemsFindFirstArgs<ExtArgs>>
    ): Prisma__listitemsClient<$Result.GetResult<Prisma.$listitemsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Listitems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listitemsFindFirstOrThrowArgs} args - Arguments to find a Listitems
     * @example
     * // Get one Listitems
     * const listitems = await prisma.listitems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends listitemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, listitemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__listitemsClient<$Result.GetResult<Prisma.$listitemsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Listitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listitemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Listitems
     * const listitems = await prisma.listitems.findMany()
     * 
     * // Get first 10 Listitems
     * const listitems = await prisma.listitems.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const listitemsWithEmailOnly = await prisma.listitems.findMany({ select: { email: true } })
     * 
    **/
    findMany<T extends listitemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, listitemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$listitemsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Listitems.
     * @param {listitemsCreateArgs} args - Arguments to create a Listitems.
     * @example
     * // Create one Listitems
     * const Listitems = await prisma.listitems.create({
     *   data: {
     *     // ... data to create a Listitems
     *   }
     * })
     * 
    **/
    create<T extends listitemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, listitemsCreateArgs<ExtArgs>>
    ): Prisma__listitemsClient<$Result.GetResult<Prisma.$listitemsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Listitems.
     * @param {listitemsCreateManyArgs} args - Arguments to create many Listitems.
     * @example
     * // Create many Listitems
     * const listitems = await prisma.listitems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends listitemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, listitemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Listitems and returns the data saved in the database.
     * @param {listitemsCreateManyAndReturnArgs} args - Arguments to create many Listitems.
     * @example
     * // Create many Listitems
     * const listitems = await prisma.listitems.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Listitems and only return the `email`
     * const listitemsWithEmailOnly = await prisma.listitems.createManyAndReturn({ 
     *   select: { email: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends listitemsCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, listitemsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$listitemsPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Listitems.
     * @param {listitemsDeleteArgs} args - Arguments to delete one Listitems.
     * @example
     * // Delete one Listitems
     * const Listitems = await prisma.listitems.delete({
     *   where: {
     *     // ... filter to delete one Listitems
     *   }
     * })
     * 
    **/
    delete<T extends listitemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, listitemsDeleteArgs<ExtArgs>>
    ): Prisma__listitemsClient<$Result.GetResult<Prisma.$listitemsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Listitems.
     * @param {listitemsUpdateArgs} args - Arguments to update one Listitems.
     * @example
     * // Update one Listitems
     * const listitems = await prisma.listitems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends listitemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, listitemsUpdateArgs<ExtArgs>>
    ): Prisma__listitemsClient<$Result.GetResult<Prisma.$listitemsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Listitems.
     * @param {listitemsDeleteManyArgs} args - Arguments to filter Listitems to delete.
     * @example
     * // Delete a few Listitems
     * const { count } = await prisma.listitems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends listitemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, listitemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Listitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listitemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Listitems
     * const listitems = await prisma.listitems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends listitemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, listitemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Listitems.
     * @param {listitemsUpsertArgs} args - Arguments to update or create a Listitems.
     * @example
     * // Update or create a Listitems
     * const listitems = await prisma.listitems.upsert({
     *   create: {
     *     // ... data to create a Listitems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Listitems we want to update
     *   }
     * })
    **/
    upsert<T extends listitemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, listitemsUpsertArgs<ExtArgs>>
    ): Prisma__listitemsClient<$Result.GetResult<Prisma.$listitemsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Listitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listitemsCountArgs} args - Arguments to filter Listitems to count.
     * @example
     * // Count the number of Listitems
     * const count = await prisma.listitems.count({
     *   where: {
     *     // ... the filter for the Listitems we want to count
     *   }
     * })
    **/
    count<T extends listitemsCountArgs>(
      args?: Subset<T, listitemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListitemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Listitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListitemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListitemsAggregateArgs>(args: Subset<T, ListitemsAggregateArgs>): Prisma.PrismaPromise<GetListitemsAggregateType<T>>

    /**
     * Group by Listitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listitemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends listitemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: listitemsGroupByArgs['orderBy'] }
        : { orderBy?: listitemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, listitemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListitemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the listitems model
   */
  readonly fields: listitemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for listitems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__listitemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    lists<T extends listsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, listsDefaultArgs<ExtArgs>>): Prisma__listsClient<$Result.GetResult<Prisma.$listsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the listitems model
   */ 
  interface listitemsFieldRefs {
    readonly email: FieldRef<"listitems", 'String'>
    readonly listname: FieldRef<"listitems", 'String'>
    readonly rankinginlist: FieldRef<"listitems", 'Int'>
    readonly itemid: FieldRef<"listitems", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * listitems findUnique
   */
  export type listitemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listitems
     */
    select?: listitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listitemsInclude<ExtArgs> | null
    /**
     * Filter, which listitems to fetch.
     */
    where: listitemsWhereUniqueInput
  }

  /**
   * listitems findUniqueOrThrow
   */
  export type listitemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listitems
     */
    select?: listitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listitemsInclude<ExtArgs> | null
    /**
     * Filter, which listitems to fetch.
     */
    where: listitemsWhereUniqueInput
  }

  /**
   * listitems findFirst
   */
  export type listitemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listitems
     */
    select?: listitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listitemsInclude<ExtArgs> | null
    /**
     * Filter, which listitems to fetch.
     */
    where?: listitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listitems to fetch.
     */
    orderBy?: listitemsOrderByWithRelationInput | listitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for listitems.
     */
    cursor?: listitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of listitems.
     */
    distinct?: ListitemsScalarFieldEnum | ListitemsScalarFieldEnum[]
  }

  /**
   * listitems findFirstOrThrow
   */
  export type listitemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listitems
     */
    select?: listitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listitemsInclude<ExtArgs> | null
    /**
     * Filter, which listitems to fetch.
     */
    where?: listitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listitems to fetch.
     */
    orderBy?: listitemsOrderByWithRelationInput | listitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for listitems.
     */
    cursor?: listitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of listitems.
     */
    distinct?: ListitemsScalarFieldEnum | ListitemsScalarFieldEnum[]
  }

  /**
   * listitems findMany
   */
  export type listitemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listitems
     */
    select?: listitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listitemsInclude<ExtArgs> | null
    /**
     * Filter, which listitems to fetch.
     */
    where?: listitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of listitems to fetch.
     */
    orderBy?: listitemsOrderByWithRelationInput | listitemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing listitems.
     */
    cursor?: listitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` listitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` listitems.
     */
    skip?: number
    distinct?: ListitemsScalarFieldEnum | ListitemsScalarFieldEnum[]
  }

  /**
   * listitems create
   */
  export type listitemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listitems
     */
    select?: listitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listitemsInclude<ExtArgs> | null
    /**
     * The data needed to create a listitems.
     */
    data: XOR<listitemsCreateInput, listitemsUncheckedCreateInput>
  }

  /**
   * listitems createMany
   */
  export type listitemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many listitems.
     */
    data: listitemsCreateManyInput | listitemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * listitems createManyAndReturn
   */
  export type listitemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listitems
     */
    select?: listitemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many listitems.
     */
    data: listitemsCreateManyInput | listitemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listitemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * listitems update
   */
  export type listitemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listitems
     */
    select?: listitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listitemsInclude<ExtArgs> | null
    /**
     * The data needed to update a listitems.
     */
    data: XOR<listitemsUpdateInput, listitemsUncheckedUpdateInput>
    /**
     * Choose, which listitems to update.
     */
    where: listitemsWhereUniqueInput
  }

  /**
   * listitems updateMany
   */
  export type listitemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update listitems.
     */
    data: XOR<listitemsUpdateManyMutationInput, listitemsUncheckedUpdateManyInput>
    /**
     * Filter which listitems to update
     */
    where?: listitemsWhereInput
  }

  /**
   * listitems upsert
   */
  export type listitemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listitems
     */
    select?: listitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listitemsInclude<ExtArgs> | null
    /**
     * The filter to search for the listitems to update in case it exists.
     */
    where: listitemsWhereUniqueInput
    /**
     * In case the listitems found by the `where` argument doesn't exist, create a new listitems with this data.
     */
    create: XOR<listitemsCreateInput, listitemsUncheckedCreateInput>
    /**
     * In case the listitems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<listitemsUpdateInput, listitemsUncheckedUpdateInput>
  }

  /**
   * listitems delete
   */
  export type listitemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listitems
     */
    select?: listitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listitemsInclude<ExtArgs> | null
    /**
     * Filter which listitems to delete.
     */
    where: listitemsWhereUniqueInput
  }

  /**
   * listitems deleteMany
   */
  export type listitemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which listitems to delete
     */
    where?: listitemsWhereInput
  }

  /**
   * listitems without action
   */
  export type listitemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listitems
     */
    select?: listitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listitemsInclude<ExtArgs> | null
  }


  /**
   * Model lists
   */

  export type AggregateLists = {
    _count: ListsCountAggregateOutputType | null
    _min: ListsMinAggregateOutputType | null
    _max: ListsMaxAggregateOutputType | null
  }

  export type ListsMinAggregateOutputType = {
    email: string | null
    listname: string | null
    listtype: $Enums.listtype | null
  }

  export type ListsMaxAggregateOutputType = {
    email: string | null
    listname: string | null
    listtype: $Enums.listtype | null
  }

  export type ListsCountAggregateOutputType = {
    email: number
    listname: number
    listtype: number
    _all: number
  }


  export type ListsMinAggregateInputType = {
    email?: true
    listname?: true
    listtype?: true
  }

  export type ListsMaxAggregateInputType = {
    email?: true
    listname?: true
    listtype?: true
  }

  export type ListsCountAggregateInputType = {
    email?: true
    listname?: true
    listtype?: true
    _all?: true
  }

  export type ListsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lists to aggregate.
     */
    where?: listsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lists to fetch.
     */
    orderBy?: listsOrderByWithRelationInput | listsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: listsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lists
    **/
    _count?: true | ListsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListsMaxAggregateInputType
  }

  export type GetListsAggregateType<T extends ListsAggregateArgs> = {
        [P in keyof T & keyof AggregateLists]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLists[P]>
      : GetScalarType<T[P], AggregateLists[P]>
  }




  export type listsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: listsWhereInput
    orderBy?: listsOrderByWithAggregationInput | listsOrderByWithAggregationInput[]
    by: ListsScalarFieldEnum[] | ListsScalarFieldEnum
    having?: listsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListsCountAggregateInputType | true
    _min?: ListsMinAggregateInputType
    _max?: ListsMaxAggregateInputType
  }

  export type ListsGroupByOutputType = {
    email: string
    listname: string
    listtype: $Enums.listtype
    _count: ListsCountAggregateOutputType | null
    _min: ListsMinAggregateOutputType | null
    _max: ListsMaxAggregateOutputType | null
  }

  type GetListsGroupByPayload<T extends listsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListsGroupByOutputType[P]>
            : GetScalarType<T[P], ListsGroupByOutputType[P]>
        }
      >
    >


  export type listsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    listname?: boolean
    listtype?: boolean
    likes?: boolean | lists$likesArgs<ExtArgs>
    listitems?: boolean | lists$listitemsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | ListsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lists"]>

  export type listsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    listname?: boolean
    listtype?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lists"]>

  export type listsSelectScalar = {
    email?: boolean
    listname?: boolean
    listtype?: boolean
  }

  export type listsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likes?: boolean | lists$likesArgs<ExtArgs>
    listitems?: boolean | lists$listitemsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | ListsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type listsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $listsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lists"
    objects: {
      likes: Prisma.$likesPayload<ExtArgs>[]
      listitems: Prisma.$listitemsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      email: string
      listname: string
      listtype: $Enums.listtype
    }, ExtArgs["result"]["lists"]>
    composites: {}
  }

  type listsGetPayload<S extends boolean | null | undefined | listsDefaultArgs> = $Result.GetResult<Prisma.$listsPayload, S>

  type listsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<listsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ListsCountAggregateInputType | true
    }

  export interface listsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lists'], meta: { name: 'lists' } }
    /**
     * Find zero or one Lists that matches the filter.
     * @param {listsFindUniqueArgs} args - Arguments to find a Lists
     * @example
     * // Get one Lists
     * const lists = await prisma.lists.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends listsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, listsFindUniqueArgs<ExtArgs>>
    ): Prisma__listsClient<$Result.GetResult<Prisma.$listsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Lists that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {listsFindUniqueOrThrowArgs} args - Arguments to find a Lists
     * @example
     * // Get one Lists
     * const lists = await prisma.lists.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends listsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, listsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__listsClient<$Result.GetResult<Prisma.$listsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listsFindFirstArgs} args - Arguments to find a Lists
     * @example
     * // Get one Lists
     * const lists = await prisma.lists.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends listsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, listsFindFirstArgs<ExtArgs>>
    ): Prisma__listsClient<$Result.GetResult<Prisma.$listsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Lists that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listsFindFirstOrThrowArgs} args - Arguments to find a Lists
     * @example
     * // Get one Lists
     * const lists = await prisma.lists.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends listsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, listsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__listsClient<$Result.GetResult<Prisma.$listsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lists
     * const lists = await prisma.lists.findMany()
     * 
     * // Get first 10 Lists
     * const lists = await prisma.lists.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const listsWithEmailOnly = await prisma.lists.findMany({ select: { email: true } })
     * 
    **/
    findMany<T extends listsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, listsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$listsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Lists.
     * @param {listsCreateArgs} args - Arguments to create a Lists.
     * @example
     * // Create one Lists
     * const Lists = await prisma.lists.create({
     *   data: {
     *     // ... data to create a Lists
     *   }
     * })
     * 
    **/
    create<T extends listsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, listsCreateArgs<ExtArgs>>
    ): Prisma__listsClient<$Result.GetResult<Prisma.$listsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Lists.
     * @param {listsCreateManyArgs} args - Arguments to create many Lists.
     * @example
     * // Create many Lists
     * const lists = await prisma.lists.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends listsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, listsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lists and returns the data saved in the database.
     * @param {listsCreateManyAndReturnArgs} args - Arguments to create many Lists.
     * @example
     * // Create many Lists
     * const lists = await prisma.lists.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lists and only return the `email`
     * const listsWithEmailOnly = await prisma.lists.createManyAndReturn({ 
     *   select: { email: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends listsCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, listsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$listsPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Lists.
     * @param {listsDeleteArgs} args - Arguments to delete one Lists.
     * @example
     * // Delete one Lists
     * const Lists = await prisma.lists.delete({
     *   where: {
     *     // ... filter to delete one Lists
     *   }
     * })
     * 
    **/
    delete<T extends listsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, listsDeleteArgs<ExtArgs>>
    ): Prisma__listsClient<$Result.GetResult<Prisma.$listsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Lists.
     * @param {listsUpdateArgs} args - Arguments to update one Lists.
     * @example
     * // Update one Lists
     * const lists = await prisma.lists.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends listsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, listsUpdateArgs<ExtArgs>>
    ): Prisma__listsClient<$Result.GetResult<Prisma.$listsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Lists.
     * @param {listsDeleteManyArgs} args - Arguments to filter Lists to delete.
     * @example
     * // Delete a few Lists
     * const { count } = await prisma.lists.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends listsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, listsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lists
     * const lists = await prisma.lists.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends listsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, listsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lists.
     * @param {listsUpsertArgs} args - Arguments to update or create a Lists.
     * @example
     * // Update or create a Lists
     * const lists = await prisma.lists.upsert({
     *   create: {
     *     // ... data to create a Lists
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lists we want to update
     *   }
     * })
    **/
    upsert<T extends listsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, listsUpsertArgs<ExtArgs>>
    ): Prisma__listsClient<$Result.GetResult<Prisma.$listsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listsCountArgs} args - Arguments to filter Lists to count.
     * @example
     * // Count the number of Lists
     * const count = await prisma.lists.count({
     *   where: {
     *     // ... the filter for the Lists we want to count
     *   }
     * })
    **/
    count<T extends listsCountArgs>(
      args?: Subset<T, listsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListsAggregateArgs>(args: Subset<T, ListsAggregateArgs>): Prisma.PrismaPromise<GetListsAggregateType<T>>

    /**
     * Group by Lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {listsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends listsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: listsGroupByArgs['orderBy'] }
        : { orderBy?: listsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, listsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lists model
   */
  readonly fields: listsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lists.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__listsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    likes<T extends lists$likesArgs<ExtArgs> = {}>(args?: Subset<T, lists$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, 'findMany'> | Null>;

    listitems<T extends lists$listitemsArgs<ExtArgs> = {}>(args?: Subset<T, lists$listitemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$listitemsPayload<ExtArgs>, T, 'findMany'> | Null>;

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the lists model
   */ 
  interface listsFieldRefs {
    readonly email: FieldRef<"lists", 'String'>
    readonly listname: FieldRef<"lists", 'String'>
    readonly listtype: FieldRef<"lists", 'listtype'>
  }
    

  // Custom InputTypes
  /**
   * lists findUnique
   */
  export type listsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lists
     */
    select?: listsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listsInclude<ExtArgs> | null
    /**
     * Filter, which lists to fetch.
     */
    where: listsWhereUniqueInput
  }

  /**
   * lists findUniqueOrThrow
   */
  export type listsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lists
     */
    select?: listsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listsInclude<ExtArgs> | null
    /**
     * Filter, which lists to fetch.
     */
    where: listsWhereUniqueInput
  }

  /**
   * lists findFirst
   */
  export type listsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lists
     */
    select?: listsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listsInclude<ExtArgs> | null
    /**
     * Filter, which lists to fetch.
     */
    where?: listsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lists to fetch.
     */
    orderBy?: listsOrderByWithRelationInput | listsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lists.
     */
    cursor?: listsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lists.
     */
    distinct?: ListsScalarFieldEnum | ListsScalarFieldEnum[]
  }

  /**
   * lists findFirstOrThrow
   */
  export type listsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lists
     */
    select?: listsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listsInclude<ExtArgs> | null
    /**
     * Filter, which lists to fetch.
     */
    where?: listsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lists to fetch.
     */
    orderBy?: listsOrderByWithRelationInput | listsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lists.
     */
    cursor?: listsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lists.
     */
    distinct?: ListsScalarFieldEnum | ListsScalarFieldEnum[]
  }

  /**
   * lists findMany
   */
  export type listsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lists
     */
    select?: listsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listsInclude<ExtArgs> | null
    /**
     * Filter, which lists to fetch.
     */
    where?: listsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lists to fetch.
     */
    orderBy?: listsOrderByWithRelationInput | listsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lists.
     */
    cursor?: listsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lists.
     */
    skip?: number
    distinct?: ListsScalarFieldEnum | ListsScalarFieldEnum[]
  }

  /**
   * lists create
   */
  export type listsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lists
     */
    select?: listsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listsInclude<ExtArgs> | null
    /**
     * The data needed to create a lists.
     */
    data: XOR<listsCreateInput, listsUncheckedCreateInput>
  }

  /**
   * lists createMany
   */
  export type listsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lists.
     */
    data: listsCreateManyInput | listsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lists createManyAndReturn
   */
  export type listsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lists
     */
    select?: listsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many lists.
     */
    data: listsCreateManyInput | listsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * lists update
   */
  export type listsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lists
     */
    select?: listsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listsInclude<ExtArgs> | null
    /**
     * The data needed to update a lists.
     */
    data: XOR<listsUpdateInput, listsUncheckedUpdateInput>
    /**
     * Choose, which lists to update.
     */
    where: listsWhereUniqueInput
  }

  /**
   * lists updateMany
   */
  export type listsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lists.
     */
    data: XOR<listsUpdateManyMutationInput, listsUncheckedUpdateManyInput>
    /**
     * Filter which lists to update
     */
    where?: listsWhereInput
  }

  /**
   * lists upsert
   */
  export type listsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lists
     */
    select?: listsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listsInclude<ExtArgs> | null
    /**
     * The filter to search for the lists to update in case it exists.
     */
    where: listsWhereUniqueInput
    /**
     * In case the lists found by the `where` argument doesn't exist, create a new lists with this data.
     */
    create: XOR<listsCreateInput, listsUncheckedCreateInput>
    /**
     * In case the lists was found with the provided `where` argument, update it with this data.
     */
    update: XOR<listsUpdateInput, listsUncheckedUpdateInput>
  }

  /**
   * lists delete
   */
  export type listsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lists
     */
    select?: listsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listsInclude<ExtArgs> | null
    /**
     * Filter which lists to delete.
     */
    where: listsWhereUniqueInput
  }

  /**
   * lists deleteMany
   */
  export type listsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lists to delete
     */
    where?: listsWhereInput
  }

  /**
   * lists.likes
   */
  export type lists$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    where?: likesWhereInput
    orderBy?: likesOrderByWithRelationInput | likesOrderByWithRelationInput[]
    cursor?: likesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikesScalarFieldEnum | LikesScalarFieldEnum[]
  }

  /**
   * lists.listitems
   */
  export type lists$listitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the listitems
     */
    select?: listitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listitemsInclude<ExtArgs> | null
    where?: listitemsWhereInput
    orderBy?: listitemsOrderByWithRelationInput | listitemsOrderByWithRelationInput[]
    cursor?: listitemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListitemsScalarFieldEnum | ListitemsScalarFieldEnum[]
  }

  /**
   * lists without action
   */
  export type listsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lists
     */
    select?: listsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listsInclude<ExtArgs> | null
  }


  /**
   * Model movies
   */

  export type AggregateMovies = {
    _count: MoviesCountAggregateOutputType | null
    _avg: MoviesAvgAggregateOutputType | null
    _sum: MoviesSumAggregateOutputType | null
    _min: MoviesMinAggregateOutputType | null
    _max: MoviesMaxAggregateOutputType | null
  }

  export type MoviesAvgAggregateOutputType = {
    id: number | null
  }

  export type MoviesSumAggregateOutputType = {
    id: number | null
  }

  export type MoviesMinAggregateOutputType = {
    id: number | null
    title: string | null
    mediaimage: string | null
    createdon: Date | null
  }

  export type MoviesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    mediaimage: string | null
    createdon: Date | null
  }

  export type MoviesCountAggregateOutputType = {
    id: number
    title: number
    mediaimage: number
    createdon: number
    _all: number
  }


  export type MoviesAvgAggregateInputType = {
    id?: true
  }

  export type MoviesSumAggregateInputType = {
    id?: true
  }

  export type MoviesMinAggregateInputType = {
    id?: true
    title?: true
    mediaimage?: true
    createdon?: true
  }

  export type MoviesMaxAggregateInputType = {
    id?: true
    title?: true
    mediaimage?: true
    createdon?: true
  }

  export type MoviesCountAggregateInputType = {
    id?: true
    title?: true
    mediaimage?: true
    createdon?: true
    _all?: true
  }

  export type MoviesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which movies to aggregate.
     */
    where?: moviesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movies to fetch.
     */
    orderBy?: moviesOrderByWithRelationInput | moviesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: moviesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned movies
    **/
    _count?: true | MoviesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MoviesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MoviesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MoviesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MoviesMaxAggregateInputType
  }

  export type GetMoviesAggregateType<T extends MoviesAggregateArgs> = {
        [P in keyof T & keyof AggregateMovies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovies[P]>
      : GetScalarType<T[P], AggregateMovies[P]>
  }




  export type moviesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: moviesWhereInput
    orderBy?: moviesOrderByWithAggregationInput | moviesOrderByWithAggregationInput[]
    by: MoviesScalarFieldEnum[] | MoviesScalarFieldEnum
    having?: moviesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MoviesCountAggregateInputType | true
    _avg?: MoviesAvgAggregateInputType
    _sum?: MoviesSumAggregateInputType
    _min?: MoviesMinAggregateInputType
    _max?: MoviesMaxAggregateInputType
  }

  export type MoviesGroupByOutputType = {
    id: number
    title: string
    mediaimage: string | null
    createdon: Date | null
    _count: MoviesCountAggregateOutputType | null
    _avg: MoviesAvgAggregateOutputType | null
    _sum: MoviesSumAggregateOutputType | null
    _min: MoviesMinAggregateOutputType | null
    _max: MoviesMaxAggregateOutputType | null
  }

  type GetMoviesGroupByPayload<T extends moviesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MoviesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MoviesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MoviesGroupByOutputType[P]>
            : GetScalarType<T[P], MoviesGroupByOutputType[P]>
        }
      >
    >


  export type moviesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    mediaimage?: boolean
    createdon?: boolean
  }, ExtArgs["result"]["movies"]>

  export type moviesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    mediaimage?: boolean
    createdon?: boolean
  }, ExtArgs["result"]["movies"]>

  export type moviesSelectScalar = {
    id?: boolean
    title?: boolean
    mediaimage?: boolean
    createdon?: boolean
  }


  export type $moviesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "movies"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      mediaimage: string | null
      createdon: Date | null
    }, ExtArgs["result"]["movies"]>
    composites: {}
  }

  type moviesGetPayload<S extends boolean | null | undefined | moviesDefaultArgs> = $Result.GetResult<Prisma.$moviesPayload, S>

  type moviesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<moviesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MoviesCountAggregateInputType | true
    }

  export interface moviesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['movies'], meta: { name: 'movies' } }
    /**
     * Find zero or one Movies that matches the filter.
     * @param {moviesFindUniqueArgs} args - Arguments to find a Movies
     * @example
     * // Get one Movies
     * const movies = await prisma.movies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends moviesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, moviesFindUniqueArgs<ExtArgs>>
    ): Prisma__moviesClient<$Result.GetResult<Prisma.$moviesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Movies that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {moviesFindUniqueOrThrowArgs} args - Arguments to find a Movies
     * @example
     * // Get one Movies
     * const movies = await prisma.movies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends moviesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, moviesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__moviesClient<$Result.GetResult<Prisma.$moviesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Movies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moviesFindFirstArgs} args - Arguments to find a Movies
     * @example
     * // Get one Movies
     * const movies = await prisma.movies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends moviesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, moviesFindFirstArgs<ExtArgs>>
    ): Prisma__moviesClient<$Result.GetResult<Prisma.$moviesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Movies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moviesFindFirstOrThrowArgs} args - Arguments to find a Movies
     * @example
     * // Get one Movies
     * const movies = await prisma.movies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends moviesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, moviesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__moviesClient<$Result.GetResult<Prisma.$moviesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Movies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moviesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Movies
     * const movies = await prisma.movies.findMany()
     * 
     * // Get first 10 Movies
     * const movies = await prisma.movies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moviesWithIdOnly = await prisma.movies.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends moviesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, moviesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$moviesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Movies.
     * @param {moviesCreateArgs} args - Arguments to create a Movies.
     * @example
     * // Create one Movies
     * const Movies = await prisma.movies.create({
     *   data: {
     *     // ... data to create a Movies
     *   }
     * })
     * 
    **/
    create<T extends moviesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, moviesCreateArgs<ExtArgs>>
    ): Prisma__moviesClient<$Result.GetResult<Prisma.$moviesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Movies.
     * @param {moviesCreateManyArgs} args - Arguments to create many Movies.
     * @example
     * // Create many Movies
     * const movies = await prisma.movies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends moviesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, moviesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Movies and returns the data saved in the database.
     * @param {moviesCreateManyAndReturnArgs} args - Arguments to create many Movies.
     * @example
     * // Create many Movies
     * const movies = await prisma.movies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Movies and only return the `id`
     * const moviesWithIdOnly = await prisma.movies.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends moviesCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, moviesCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$moviesPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Movies.
     * @param {moviesDeleteArgs} args - Arguments to delete one Movies.
     * @example
     * // Delete one Movies
     * const Movies = await prisma.movies.delete({
     *   where: {
     *     // ... filter to delete one Movies
     *   }
     * })
     * 
    **/
    delete<T extends moviesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, moviesDeleteArgs<ExtArgs>>
    ): Prisma__moviesClient<$Result.GetResult<Prisma.$moviesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Movies.
     * @param {moviesUpdateArgs} args - Arguments to update one Movies.
     * @example
     * // Update one Movies
     * const movies = await prisma.movies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends moviesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, moviesUpdateArgs<ExtArgs>>
    ): Prisma__moviesClient<$Result.GetResult<Prisma.$moviesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Movies.
     * @param {moviesDeleteManyArgs} args - Arguments to filter Movies to delete.
     * @example
     * // Delete a few Movies
     * const { count } = await prisma.movies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends moviesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, moviesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moviesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Movies
     * const movies = await prisma.movies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends moviesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, moviesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Movies.
     * @param {moviesUpsertArgs} args - Arguments to update or create a Movies.
     * @example
     * // Update or create a Movies
     * const movies = await prisma.movies.upsert({
     *   create: {
     *     // ... data to create a Movies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Movies we want to update
     *   }
     * })
    **/
    upsert<T extends moviesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, moviesUpsertArgs<ExtArgs>>
    ): Prisma__moviesClient<$Result.GetResult<Prisma.$moviesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moviesCountArgs} args - Arguments to filter Movies to count.
     * @example
     * // Count the number of Movies
     * const count = await prisma.movies.count({
     *   where: {
     *     // ... the filter for the Movies we want to count
     *   }
     * })
    **/
    count<T extends moviesCountArgs>(
      args?: Subset<T, moviesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MoviesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoviesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MoviesAggregateArgs>(args: Subset<T, MoviesAggregateArgs>): Prisma.PrismaPromise<GetMoviesAggregateType<T>>

    /**
     * Group by Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {moviesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends moviesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: moviesGroupByArgs['orderBy'] }
        : { orderBy?: moviesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, moviesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMoviesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the movies model
   */
  readonly fields: moviesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for movies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__moviesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the movies model
   */ 
  interface moviesFieldRefs {
    readonly id: FieldRef<"movies", 'Int'>
    readonly title: FieldRef<"movies", 'String'>
    readonly mediaimage: FieldRef<"movies", 'String'>
    readonly createdon: FieldRef<"movies", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * movies findUnique
   */
  export type moviesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movies
     */
    select?: moviesSelect<ExtArgs> | null
    /**
     * Filter, which movies to fetch.
     */
    where: moviesWhereUniqueInput
  }

  /**
   * movies findUniqueOrThrow
   */
  export type moviesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movies
     */
    select?: moviesSelect<ExtArgs> | null
    /**
     * Filter, which movies to fetch.
     */
    where: moviesWhereUniqueInput
  }

  /**
   * movies findFirst
   */
  export type moviesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movies
     */
    select?: moviesSelect<ExtArgs> | null
    /**
     * Filter, which movies to fetch.
     */
    where?: moviesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movies to fetch.
     */
    orderBy?: moviesOrderByWithRelationInput | moviesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for movies.
     */
    cursor?: moviesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of movies.
     */
    distinct?: MoviesScalarFieldEnum | MoviesScalarFieldEnum[]
  }

  /**
   * movies findFirstOrThrow
   */
  export type moviesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movies
     */
    select?: moviesSelect<ExtArgs> | null
    /**
     * Filter, which movies to fetch.
     */
    where?: moviesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movies to fetch.
     */
    orderBy?: moviesOrderByWithRelationInput | moviesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for movies.
     */
    cursor?: moviesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of movies.
     */
    distinct?: MoviesScalarFieldEnum | MoviesScalarFieldEnum[]
  }

  /**
   * movies findMany
   */
  export type moviesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movies
     */
    select?: moviesSelect<ExtArgs> | null
    /**
     * Filter, which movies to fetch.
     */
    where?: moviesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movies to fetch.
     */
    orderBy?: moviesOrderByWithRelationInput | moviesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing movies.
     */
    cursor?: moviesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movies.
     */
    skip?: number
    distinct?: MoviesScalarFieldEnum | MoviesScalarFieldEnum[]
  }

  /**
   * movies create
   */
  export type moviesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movies
     */
    select?: moviesSelect<ExtArgs> | null
    /**
     * The data needed to create a movies.
     */
    data: XOR<moviesCreateInput, moviesUncheckedCreateInput>
  }

  /**
   * movies createMany
   */
  export type moviesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many movies.
     */
    data: moviesCreateManyInput | moviesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * movies createManyAndReturn
   */
  export type moviesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movies
     */
    select?: moviesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many movies.
     */
    data: moviesCreateManyInput | moviesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * movies update
   */
  export type moviesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movies
     */
    select?: moviesSelect<ExtArgs> | null
    /**
     * The data needed to update a movies.
     */
    data: XOR<moviesUpdateInput, moviesUncheckedUpdateInput>
    /**
     * Choose, which movies to update.
     */
    where: moviesWhereUniqueInput
  }

  /**
   * movies updateMany
   */
  export type moviesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update movies.
     */
    data: XOR<moviesUpdateManyMutationInput, moviesUncheckedUpdateManyInput>
    /**
     * Filter which movies to update
     */
    where?: moviesWhereInput
  }

  /**
   * movies upsert
   */
  export type moviesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movies
     */
    select?: moviesSelect<ExtArgs> | null
    /**
     * The filter to search for the movies to update in case it exists.
     */
    where: moviesWhereUniqueInput
    /**
     * In case the movies found by the `where` argument doesn't exist, create a new movies with this data.
     */
    create: XOR<moviesCreateInput, moviesUncheckedCreateInput>
    /**
     * In case the movies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<moviesUpdateInput, moviesUncheckedUpdateInput>
  }

  /**
   * movies delete
   */
  export type moviesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movies
     */
    select?: moviesSelect<ExtArgs> | null
    /**
     * Filter which movies to delete.
     */
    where: moviesWhereUniqueInput
  }

  /**
   * movies deleteMany
   */
  export type moviesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which movies to delete
     */
    where?: moviesWhereInput
  }

  /**
   * movies without action
   */
  export type moviesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the movies
     */
    select?: moviesSelect<ExtArgs> | null
  }


  /**
   * Model songs
   */

  export type AggregateSongs = {
    _count: SongsCountAggregateOutputType | null
    _avg: SongsAvgAggregateOutputType | null
    _sum: SongsSumAggregateOutputType | null
    _min: SongsMinAggregateOutputType | null
    _max: SongsMaxAggregateOutputType | null
  }

  export type SongsAvgAggregateOutputType = {
    id: number | null
  }

  export type SongsSumAggregateOutputType = {
    id: number | null
  }

  export type SongsMinAggregateOutputType = {
    id: number | null
    title: string | null
    author: string | null
    album: string | null
    mediaimage: string | null
    createdon: Date | null
  }

  export type SongsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    author: string | null
    album: string | null
    mediaimage: string | null
    createdon: Date | null
  }

  export type SongsCountAggregateOutputType = {
    id: number
    title: number
    author: number
    album: number
    mediaimage: number
    createdon: number
    _all: number
  }


  export type SongsAvgAggregateInputType = {
    id?: true
  }

  export type SongsSumAggregateInputType = {
    id?: true
  }

  export type SongsMinAggregateInputType = {
    id?: true
    title?: true
    author?: true
    album?: true
    mediaimage?: true
    createdon?: true
  }

  export type SongsMaxAggregateInputType = {
    id?: true
    title?: true
    author?: true
    album?: true
    mediaimage?: true
    createdon?: true
  }

  export type SongsCountAggregateInputType = {
    id?: true
    title?: true
    author?: true
    album?: true
    mediaimage?: true
    createdon?: true
    _all?: true
  }

  export type SongsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which songs to aggregate.
     */
    where?: songsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songs to fetch.
     */
    orderBy?: songsOrderByWithRelationInput | songsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: songsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned songs
    **/
    _count?: true | SongsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SongsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SongsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SongsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SongsMaxAggregateInputType
  }

  export type GetSongsAggregateType<T extends SongsAggregateArgs> = {
        [P in keyof T & keyof AggregateSongs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSongs[P]>
      : GetScalarType<T[P], AggregateSongs[P]>
  }




  export type songsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: songsWhereInput
    orderBy?: songsOrderByWithAggregationInput | songsOrderByWithAggregationInput[]
    by: SongsScalarFieldEnum[] | SongsScalarFieldEnum
    having?: songsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SongsCountAggregateInputType | true
    _avg?: SongsAvgAggregateInputType
    _sum?: SongsSumAggregateInputType
    _min?: SongsMinAggregateInputType
    _max?: SongsMaxAggregateInputType
  }

  export type SongsGroupByOutputType = {
    id: number
    title: string
    author: string | null
    album: string | null
    mediaimage: string | null
    createdon: Date | null
    _count: SongsCountAggregateOutputType | null
    _avg: SongsAvgAggregateOutputType | null
    _sum: SongsSumAggregateOutputType | null
    _min: SongsMinAggregateOutputType | null
    _max: SongsMaxAggregateOutputType | null
  }

  type GetSongsGroupByPayload<T extends songsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SongsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SongsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SongsGroupByOutputType[P]>
            : GetScalarType<T[P], SongsGroupByOutputType[P]>
        }
      >
    >


  export type songsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    author?: boolean
    album?: boolean
    mediaimage?: boolean
    createdon?: boolean
  }, ExtArgs["result"]["songs"]>

  export type songsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    author?: boolean
    album?: boolean
    mediaimage?: boolean
    createdon?: boolean
  }, ExtArgs["result"]["songs"]>

  export type songsSelectScalar = {
    id?: boolean
    title?: boolean
    author?: boolean
    album?: boolean
    mediaimage?: boolean
    createdon?: boolean
  }


  export type $songsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "songs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      author: string | null
      album: string | null
      mediaimage: string | null
      createdon: Date | null
    }, ExtArgs["result"]["songs"]>
    composites: {}
  }

  type songsGetPayload<S extends boolean | null | undefined | songsDefaultArgs> = $Result.GetResult<Prisma.$songsPayload, S>

  type songsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<songsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SongsCountAggregateInputType | true
    }

  export interface songsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['songs'], meta: { name: 'songs' } }
    /**
     * Find zero or one Songs that matches the filter.
     * @param {songsFindUniqueArgs} args - Arguments to find a Songs
     * @example
     * // Get one Songs
     * const songs = await prisma.songs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends songsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, songsFindUniqueArgs<ExtArgs>>
    ): Prisma__songsClient<$Result.GetResult<Prisma.$songsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Songs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {songsFindUniqueOrThrowArgs} args - Arguments to find a Songs
     * @example
     * // Get one Songs
     * const songs = await prisma.songs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends songsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, songsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__songsClient<$Result.GetResult<Prisma.$songsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Songs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songsFindFirstArgs} args - Arguments to find a Songs
     * @example
     * // Get one Songs
     * const songs = await prisma.songs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends songsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, songsFindFirstArgs<ExtArgs>>
    ): Prisma__songsClient<$Result.GetResult<Prisma.$songsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Songs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songsFindFirstOrThrowArgs} args - Arguments to find a Songs
     * @example
     * // Get one Songs
     * const songs = await prisma.songs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends songsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, songsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__songsClient<$Result.GetResult<Prisma.$songsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Songs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Songs
     * const songs = await prisma.songs.findMany()
     * 
     * // Get first 10 Songs
     * const songs = await prisma.songs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const songsWithIdOnly = await prisma.songs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends songsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, songsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$songsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Songs.
     * @param {songsCreateArgs} args - Arguments to create a Songs.
     * @example
     * // Create one Songs
     * const Songs = await prisma.songs.create({
     *   data: {
     *     // ... data to create a Songs
     *   }
     * })
     * 
    **/
    create<T extends songsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, songsCreateArgs<ExtArgs>>
    ): Prisma__songsClient<$Result.GetResult<Prisma.$songsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Songs.
     * @param {songsCreateManyArgs} args - Arguments to create many Songs.
     * @example
     * // Create many Songs
     * const songs = await prisma.songs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends songsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, songsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Songs and returns the data saved in the database.
     * @param {songsCreateManyAndReturnArgs} args - Arguments to create many Songs.
     * @example
     * // Create many Songs
     * const songs = await prisma.songs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Songs and only return the `id`
     * const songsWithIdOnly = await prisma.songs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends songsCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, songsCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$songsPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Songs.
     * @param {songsDeleteArgs} args - Arguments to delete one Songs.
     * @example
     * // Delete one Songs
     * const Songs = await prisma.songs.delete({
     *   where: {
     *     // ... filter to delete one Songs
     *   }
     * })
     * 
    **/
    delete<T extends songsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, songsDeleteArgs<ExtArgs>>
    ): Prisma__songsClient<$Result.GetResult<Prisma.$songsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Songs.
     * @param {songsUpdateArgs} args - Arguments to update one Songs.
     * @example
     * // Update one Songs
     * const songs = await prisma.songs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends songsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, songsUpdateArgs<ExtArgs>>
    ): Prisma__songsClient<$Result.GetResult<Prisma.$songsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Songs.
     * @param {songsDeleteManyArgs} args - Arguments to filter Songs to delete.
     * @example
     * // Delete a few Songs
     * const { count } = await prisma.songs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends songsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, songsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Songs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Songs
     * const songs = await prisma.songs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends songsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, songsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Songs.
     * @param {songsUpsertArgs} args - Arguments to update or create a Songs.
     * @example
     * // Update or create a Songs
     * const songs = await prisma.songs.upsert({
     *   create: {
     *     // ... data to create a Songs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Songs we want to update
     *   }
     * })
    **/
    upsert<T extends songsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, songsUpsertArgs<ExtArgs>>
    ): Prisma__songsClient<$Result.GetResult<Prisma.$songsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Songs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songsCountArgs} args - Arguments to filter Songs to count.
     * @example
     * // Count the number of Songs
     * const count = await prisma.songs.count({
     *   where: {
     *     // ... the filter for the Songs we want to count
     *   }
     * })
    **/
    count<T extends songsCountArgs>(
      args?: Subset<T, songsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SongsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Songs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SongsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SongsAggregateArgs>(args: Subset<T, SongsAggregateArgs>): Prisma.PrismaPromise<GetSongsAggregateType<T>>

    /**
     * Group by Songs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {songsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends songsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: songsGroupByArgs['orderBy'] }
        : { orderBy?: songsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, songsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSongsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the songs model
   */
  readonly fields: songsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for songs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__songsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the songs model
   */ 
  interface songsFieldRefs {
    readonly id: FieldRef<"songs", 'Int'>
    readonly title: FieldRef<"songs", 'String'>
    readonly author: FieldRef<"songs", 'String'>
    readonly album: FieldRef<"songs", 'String'>
    readonly mediaimage: FieldRef<"songs", 'String'>
    readonly createdon: FieldRef<"songs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * songs findUnique
   */
  export type songsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songs
     */
    select?: songsSelect<ExtArgs> | null
    /**
     * Filter, which songs to fetch.
     */
    where: songsWhereUniqueInput
  }

  /**
   * songs findUniqueOrThrow
   */
  export type songsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songs
     */
    select?: songsSelect<ExtArgs> | null
    /**
     * Filter, which songs to fetch.
     */
    where: songsWhereUniqueInput
  }

  /**
   * songs findFirst
   */
  export type songsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songs
     */
    select?: songsSelect<ExtArgs> | null
    /**
     * Filter, which songs to fetch.
     */
    where?: songsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songs to fetch.
     */
    orderBy?: songsOrderByWithRelationInput | songsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for songs.
     */
    cursor?: songsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of songs.
     */
    distinct?: SongsScalarFieldEnum | SongsScalarFieldEnum[]
  }

  /**
   * songs findFirstOrThrow
   */
  export type songsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songs
     */
    select?: songsSelect<ExtArgs> | null
    /**
     * Filter, which songs to fetch.
     */
    where?: songsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songs to fetch.
     */
    orderBy?: songsOrderByWithRelationInput | songsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for songs.
     */
    cursor?: songsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of songs.
     */
    distinct?: SongsScalarFieldEnum | SongsScalarFieldEnum[]
  }

  /**
   * songs findMany
   */
  export type songsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songs
     */
    select?: songsSelect<ExtArgs> | null
    /**
     * Filter, which songs to fetch.
     */
    where?: songsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of songs to fetch.
     */
    orderBy?: songsOrderByWithRelationInput | songsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing songs.
     */
    cursor?: songsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` songs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` songs.
     */
    skip?: number
    distinct?: SongsScalarFieldEnum | SongsScalarFieldEnum[]
  }

  /**
   * songs create
   */
  export type songsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songs
     */
    select?: songsSelect<ExtArgs> | null
    /**
     * The data needed to create a songs.
     */
    data: XOR<songsCreateInput, songsUncheckedCreateInput>
  }

  /**
   * songs createMany
   */
  export type songsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many songs.
     */
    data: songsCreateManyInput | songsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * songs createManyAndReturn
   */
  export type songsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songs
     */
    select?: songsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many songs.
     */
    data: songsCreateManyInput | songsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * songs update
   */
  export type songsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songs
     */
    select?: songsSelect<ExtArgs> | null
    /**
     * The data needed to update a songs.
     */
    data: XOR<songsUpdateInput, songsUncheckedUpdateInput>
    /**
     * Choose, which songs to update.
     */
    where: songsWhereUniqueInput
  }

  /**
   * songs updateMany
   */
  export type songsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update songs.
     */
    data: XOR<songsUpdateManyMutationInput, songsUncheckedUpdateManyInput>
    /**
     * Filter which songs to update
     */
    where?: songsWhereInput
  }

  /**
   * songs upsert
   */
  export type songsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songs
     */
    select?: songsSelect<ExtArgs> | null
    /**
     * The filter to search for the songs to update in case it exists.
     */
    where: songsWhereUniqueInput
    /**
     * In case the songs found by the `where` argument doesn't exist, create a new songs with this data.
     */
    create: XOR<songsCreateInput, songsUncheckedCreateInput>
    /**
     * In case the songs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<songsUpdateInput, songsUncheckedUpdateInput>
  }

  /**
   * songs delete
   */
  export type songsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songs
     */
    select?: songsSelect<ExtArgs> | null
    /**
     * Filter which songs to delete.
     */
    where: songsWhereUniqueInput
  }

  /**
   * songs deleteMany
   */
  export type songsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which songs to delete
     */
    where?: songsWhereInput
  }

  /**
   * songs without action
   */
  export type songsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the songs
     */
    select?: songsSelect<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    email: string | null
    displayname: string | null
    userpassword: string | null
    createdat: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    email: string | null
    displayname: string | null
    userpassword: string | null
    createdat: Date | null
  }

  export type UsersCountAggregateOutputType = {
    email: number
    displayname: number
    userpassword: number
    createdat: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    email?: true
    displayname?: true
    userpassword?: true
    createdat?: true
  }

  export type UsersMaxAggregateInputType = {
    email?: true
    displayname?: true
    userpassword?: true
    createdat?: true
  }

  export type UsersCountAggregateInputType = {
    email?: true
    displayname?: true
    userpassword?: true
    createdat?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    email: string
    displayname: string
    userpassword: string
    createdat: Date | null
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    displayname?: boolean
    userpassword?: boolean
    createdat?: boolean
    follows_follows_followeremailTousers?: boolean | users$follows_follows_followeremailTousersArgs<ExtArgs>
    follows_follows_followingemailTousers?: boolean | users$follows_follows_followingemailTousersArgs<ExtArgs>
    groupmembers?: boolean | users$groupmembersArgs<ExtArgs>
    groups?: boolean | users$groupsArgs<ExtArgs>
    likes?: boolean | users$likesArgs<ExtArgs>
    lists?: boolean | users$listsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    displayname?: boolean
    userpassword?: boolean
    createdat?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    email?: boolean
    displayname?: boolean
    userpassword?: boolean
    createdat?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follows_follows_followeremailTousers?: boolean | users$follows_follows_followeremailTousersArgs<ExtArgs>
    follows_follows_followingemailTousers?: boolean | users$follows_follows_followingemailTousersArgs<ExtArgs>
    groupmembers?: boolean | users$groupmembersArgs<ExtArgs>
    groups?: boolean | users$groupsArgs<ExtArgs>
    likes?: boolean | users$likesArgs<ExtArgs>
    lists?: boolean | users$listsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      follows_follows_followeremailTousers: Prisma.$followsPayload<ExtArgs>[]
      follows_follows_followingemailTousers: Prisma.$followsPayload<ExtArgs>[]
      groupmembers: Prisma.$groupmembersPayload<ExtArgs>[]
      groups: Prisma.$groupsPayload<ExtArgs>[]
      likes: Prisma.$likesPayload<ExtArgs>[]
      lists: Prisma.$listsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      email: string
      displayname: string
      userpassword: string
      createdat: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const usersWithEmailOnly = await prisma.users.findMany({ select: { email: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, usersCreateArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends usersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `email`
     * const usersWithEmailOnly = await prisma.users.createManyAndReturn({ 
     *   select: { email: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends usersCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, usersDeleteArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpsertArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    follows_follows_followeremailTousers<T extends users$follows_follows_followeremailTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$follows_follows_followeremailTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, 'findMany'> | Null>;

    follows_follows_followingemailTousers<T extends users$follows_follows_followingemailTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$follows_follows_followingemailTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followsPayload<ExtArgs>, T, 'findMany'> | Null>;

    groupmembers<T extends users$groupmembersArgs<ExtArgs> = {}>(args?: Subset<T, users$groupmembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupmembersPayload<ExtArgs>, T, 'findMany'> | Null>;

    groups<T extends users$groupsArgs<ExtArgs> = {}>(args?: Subset<T, users$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, 'findMany'> | Null>;

    likes<T extends users$likesArgs<ExtArgs> = {}>(args?: Subset<T, users$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$likesPayload<ExtArgs>, T, 'findMany'> | Null>;

    lists<T extends users$listsArgs<ExtArgs> = {}>(args?: Subset<T, users$listsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$listsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly email: FieldRef<"users", 'String'>
    readonly displayname: FieldRef<"users", 'String'>
    readonly userpassword: FieldRef<"users", 'String'>
    readonly createdat: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users.follows_follows_followeremailTousers
   */
  export type users$follows_follows_followeremailTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    where?: followsWhereInput
    orderBy?: followsOrderByWithRelationInput | followsOrderByWithRelationInput[]
    cursor?: followsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowsScalarFieldEnum | FollowsScalarFieldEnum[]
  }

  /**
   * users.follows_follows_followingemailTousers
   */
  export type users$follows_follows_followingemailTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the follows
     */
    select?: followsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followsInclude<ExtArgs> | null
    where?: followsWhereInput
    orderBy?: followsOrderByWithRelationInput | followsOrderByWithRelationInput[]
    cursor?: followsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowsScalarFieldEnum | FollowsScalarFieldEnum[]
  }

  /**
   * users.groupmembers
   */
  export type users$groupmembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groupmembers
     */
    select?: groupmembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupmembersInclude<ExtArgs> | null
    where?: groupmembersWhereInput
    orderBy?: groupmembersOrderByWithRelationInput | groupmembersOrderByWithRelationInput[]
    cursor?: groupmembersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupmembersScalarFieldEnum | GroupmembersScalarFieldEnum[]
  }

  /**
   * users.groups
   */
  export type users$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: groupsInclude<ExtArgs> | null
    where?: groupsWhereInput
    orderBy?: groupsOrderByWithRelationInput | groupsOrderByWithRelationInput[]
    cursor?: groupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * users.likes
   */
  export type users$likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the likes
     */
    select?: likesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: likesInclude<ExtArgs> | null
    where?: likesWhereInput
    orderBy?: likesOrderByWithRelationInput | likesOrderByWithRelationInput[]
    cursor?: likesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LikesScalarFieldEnum | LikesScalarFieldEnum[]
  }

  /**
   * users.lists
   */
  export type users$listsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lists
     */
    select?: listsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: listsInclude<ExtArgs> | null
    where?: listsWhereInput
    orderBy?: listsOrderByWithRelationInput | listsOrderByWithRelationInput[]
    cursor?: listsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListsScalarFieldEnum | ListsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model videogames
   */

  export type AggregateVideogames = {
    _count: VideogamesCountAggregateOutputType | null
    _avg: VideogamesAvgAggregateOutputType | null
    _sum: VideogamesSumAggregateOutputType | null
    _min: VideogamesMinAggregateOutputType | null
    _max: VideogamesMaxAggregateOutputType | null
  }

  export type VideogamesAvgAggregateOutputType = {
    id: number | null
  }

  export type VideogamesSumAggregateOutputType = {
    id: number | null
  }

  export type VideogamesMinAggregateOutputType = {
    id: number | null
    title: string | null
    mediaimage: string | null
    console: string | null
    createdon: Date | null
  }

  export type VideogamesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    mediaimage: string | null
    console: string | null
    createdon: Date | null
  }

  export type VideogamesCountAggregateOutputType = {
    id: number
    title: number
    mediaimage: number
    console: number
    createdon: number
    _all: number
  }


  export type VideogamesAvgAggregateInputType = {
    id?: true
  }

  export type VideogamesSumAggregateInputType = {
    id?: true
  }

  export type VideogamesMinAggregateInputType = {
    id?: true
    title?: true
    mediaimage?: true
    console?: true
    createdon?: true
  }

  export type VideogamesMaxAggregateInputType = {
    id?: true
    title?: true
    mediaimage?: true
    console?: true
    createdon?: true
  }

  export type VideogamesCountAggregateInputType = {
    id?: true
    title?: true
    mediaimage?: true
    console?: true
    createdon?: true
    _all?: true
  }

  export type VideogamesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videogames to aggregate.
     */
    where?: videogamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videogames to fetch.
     */
    orderBy?: videogamesOrderByWithRelationInput | videogamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: videogamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videogames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videogames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned videogames
    **/
    _count?: true | VideogamesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideogamesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideogamesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideogamesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideogamesMaxAggregateInputType
  }

  export type GetVideogamesAggregateType<T extends VideogamesAggregateArgs> = {
        [P in keyof T & keyof AggregateVideogames]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideogames[P]>
      : GetScalarType<T[P], AggregateVideogames[P]>
  }




  export type videogamesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: videogamesWhereInput
    orderBy?: videogamesOrderByWithAggregationInput | videogamesOrderByWithAggregationInput[]
    by: VideogamesScalarFieldEnum[] | VideogamesScalarFieldEnum
    having?: videogamesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideogamesCountAggregateInputType | true
    _avg?: VideogamesAvgAggregateInputType
    _sum?: VideogamesSumAggregateInputType
    _min?: VideogamesMinAggregateInputType
    _max?: VideogamesMaxAggregateInputType
  }

  export type VideogamesGroupByOutputType = {
    id: number
    title: string
    mediaimage: string | null
    console: string | null
    createdon: Date | null
    _count: VideogamesCountAggregateOutputType | null
    _avg: VideogamesAvgAggregateOutputType | null
    _sum: VideogamesSumAggregateOutputType | null
    _min: VideogamesMinAggregateOutputType | null
    _max: VideogamesMaxAggregateOutputType | null
  }

  type GetVideogamesGroupByPayload<T extends videogamesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideogamesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideogamesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideogamesGroupByOutputType[P]>
            : GetScalarType<T[P], VideogamesGroupByOutputType[P]>
        }
      >
    >


  export type videogamesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    mediaimage?: boolean
    console?: boolean
    createdon?: boolean
  }, ExtArgs["result"]["videogames"]>

  export type videogamesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    mediaimage?: boolean
    console?: boolean
    createdon?: boolean
  }, ExtArgs["result"]["videogames"]>

  export type videogamesSelectScalar = {
    id?: boolean
    title?: boolean
    mediaimage?: boolean
    console?: boolean
    createdon?: boolean
  }


  export type $videogamesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "videogames"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      mediaimage: string | null
      console: string | null
      createdon: Date | null
    }, ExtArgs["result"]["videogames"]>
    composites: {}
  }

  type videogamesGetPayload<S extends boolean | null | undefined | videogamesDefaultArgs> = $Result.GetResult<Prisma.$videogamesPayload, S>

  type videogamesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<videogamesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VideogamesCountAggregateInputType | true
    }

  export interface videogamesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['videogames'], meta: { name: 'videogames' } }
    /**
     * Find zero or one Videogames that matches the filter.
     * @param {videogamesFindUniqueArgs} args - Arguments to find a Videogames
     * @example
     * // Get one Videogames
     * const videogames = await prisma.videogames.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends videogamesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, videogamesFindUniqueArgs<ExtArgs>>
    ): Prisma__videogamesClient<$Result.GetResult<Prisma.$videogamesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Videogames that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {videogamesFindUniqueOrThrowArgs} args - Arguments to find a Videogames
     * @example
     * // Get one Videogames
     * const videogames = await prisma.videogames.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends videogamesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, videogamesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__videogamesClient<$Result.GetResult<Prisma.$videogamesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Videogames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videogamesFindFirstArgs} args - Arguments to find a Videogames
     * @example
     * // Get one Videogames
     * const videogames = await prisma.videogames.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends videogamesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, videogamesFindFirstArgs<ExtArgs>>
    ): Prisma__videogamesClient<$Result.GetResult<Prisma.$videogamesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Videogames that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videogamesFindFirstOrThrowArgs} args - Arguments to find a Videogames
     * @example
     * // Get one Videogames
     * const videogames = await prisma.videogames.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends videogamesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, videogamesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__videogamesClient<$Result.GetResult<Prisma.$videogamesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Videogames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videogamesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videogames
     * const videogames = await prisma.videogames.findMany()
     * 
     * // Get first 10 Videogames
     * const videogames = await prisma.videogames.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videogamesWithIdOnly = await prisma.videogames.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends videogamesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, videogamesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videogamesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Videogames.
     * @param {videogamesCreateArgs} args - Arguments to create a Videogames.
     * @example
     * // Create one Videogames
     * const Videogames = await prisma.videogames.create({
     *   data: {
     *     // ... data to create a Videogames
     *   }
     * })
     * 
    **/
    create<T extends videogamesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, videogamesCreateArgs<ExtArgs>>
    ): Prisma__videogamesClient<$Result.GetResult<Prisma.$videogamesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Videogames.
     * @param {videogamesCreateManyArgs} args - Arguments to create many Videogames.
     * @example
     * // Create many Videogames
     * const videogames = await prisma.videogames.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends videogamesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, videogamesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Videogames and returns the data saved in the database.
     * @param {videogamesCreateManyAndReturnArgs} args - Arguments to create many Videogames.
     * @example
     * // Create many Videogames
     * const videogames = await prisma.videogames.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Videogames and only return the `id`
     * const videogamesWithIdOnly = await prisma.videogames.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
    **/
    createManyAndReturn<T extends videogamesCreateManyAndReturnArgs<ExtArgs>>(
      args?: SelectSubset<T, videogamesCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$videogamesPayload<ExtArgs>, T, 'createManyAndReturn'>>

    /**
     * Delete a Videogames.
     * @param {videogamesDeleteArgs} args - Arguments to delete one Videogames.
     * @example
     * // Delete one Videogames
     * const Videogames = await prisma.videogames.delete({
     *   where: {
     *     // ... filter to delete one Videogames
     *   }
     * })
     * 
    **/
    delete<T extends videogamesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, videogamesDeleteArgs<ExtArgs>>
    ): Prisma__videogamesClient<$Result.GetResult<Prisma.$videogamesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Videogames.
     * @param {videogamesUpdateArgs} args - Arguments to update one Videogames.
     * @example
     * // Update one Videogames
     * const videogames = await prisma.videogames.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends videogamesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, videogamesUpdateArgs<ExtArgs>>
    ): Prisma__videogamesClient<$Result.GetResult<Prisma.$videogamesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Videogames.
     * @param {videogamesDeleteManyArgs} args - Arguments to filter Videogames to delete.
     * @example
     * // Delete a few Videogames
     * const { count } = await prisma.videogames.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends videogamesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, videogamesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videogames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videogamesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videogames
     * const videogames = await prisma.videogames.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends videogamesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, videogamesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Videogames.
     * @param {videogamesUpsertArgs} args - Arguments to update or create a Videogames.
     * @example
     * // Update or create a Videogames
     * const videogames = await prisma.videogames.upsert({
     *   create: {
     *     // ... data to create a Videogames
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Videogames we want to update
     *   }
     * })
    **/
    upsert<T extends videogamesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, videogamesUpsertArgs<ExtArgs>>
    ): Prisma__videogamesClient<$Result.GetResult<Prisma.$videogamesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Videogames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videogamesCountArgs} args - Arguments to filter Videogames to count.
     * @example
     * // Count the number of Videogames
     * const count = await prisma.videogames.count({
     *   where: {
     *     // ... the filter for the Videogames we want to count
     *   }
     * })
    **/
    count<T extends videogamesCountArgs>(
      args?: Subset<T, videogamesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideogamesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Videogames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideogamesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideogamesAggregateArgs>(args: Subset<T, VideogamesAggregateArgs>): Prisma.PrismaPromise<GetVideogamesAggregateType<T>>

    /**
     * Group by Videogames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {videogamesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends videogamesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: videogamesGroupByArgs['orderBy'] }
        : { orderBy?: videogamesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, videogamesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideogamesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the videogames model
   */
  readonly fields: videogamesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for videogames.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__videogamesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the videogames model
   */ 
  interface videogamesFieldRefs {
    readonly id: FieldRef<"videogames", 'Int'>
    readonly title: FieldRef<"videogames", 'String'>
    readonly mediaimage: FieldRef<"videogames", 'String'>
    readonly console: FieldRef<"videogames", 'String'>
    readonly createdon: FieldRef<"videogames", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * videogames findUnique
   */
  export type videogamesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videogames
     */
    select?: videogamesSelect<ExtArgs> | null
    /**
     * Filter, which videogames to fetch.
     */
    where: videogamesWhereUniqueInput
  }

  /**
   * videogames findUniqueOrThrow
   */
  export type videogamesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videogames
     */
    select?: videogamesSelect<ExtArgs> | null
    /**
     * Filter, which videogames to fetch.
     */
    where: videogamesWhereUniqueInput
  }

  /**
   * videogames findFirst
   */
  export type videogamesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videogames
     */
    select?: videogamesSelect<ExtArgs> | null
    /**
     * Filter, which videogames to fetch.
     */
    where?: videogamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videogames to fetch.
     */
    orderBy?: videogamesOrderByWithRelationInput | videogamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videogames.
     */
    cursor?: videogamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videogames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videogames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videogames.
     */
    distinct?: VideogamesScalarFieldEnum | VideogamesScalarFieldEnum[]
  }

  /**
   * videogames findFirstOrThrow
   */
  export type videogamesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videogames
     */
    select?: videogamesSelect<ExtArgs> | null
    /**
     * Filter, which videogames to fetch.
     */
    where?: videogamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videogames to fetch.
     */
    orderBy?: videogamesOrderByWithRelationInput | videogamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for videogames.
     */
    cursor?: videogamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videogames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videogames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of videogames.
     */
    distinct?: VideogamesScalarFieldEnum | VideogamesScalarFieldEnum[]
  }

  /**
   * videogames findMany
   */
  export type videogamesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videogames
     */
    select?: videogamesSelect<ExtArgs> | null
    /**
     * Filter, which videogames to fetch.
     */
    where?: videogamesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of videogames to fetch.
     */
    orderBy?: videogamesOrderByWithRelationInput | videogamesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing videogames.
     */
    cursor?: videogamesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` videogames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` videogames.
     */
    skip?: number
    distinct?: VideogamesScalarFieldEnum | VideogamesScalarFieldEnum[]
  }

  /**
   * videogames create
   */
  export type videogamesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videogames
     */
    select?: videogamesSelect<ExtArgs> | null
    /**
     * The data needed to create a videogames.
     */
    data: XOR<videogamesCreateInput, videogamesUncheckedCreateInput>
  }

  /**
   * videogames createMany
   */
  export type videogamesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many videogames.
     */
    data: videogamesCreateManyInput | videogamesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * videogames createManyAndReturn
   */
  export type videogamesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videogames
     */
    select?: videogamesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many videogames.
     */
    data: videogamesCreateManyInput | videogamesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * videogames update
   */
  export type videogamesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videogames
     */
    select?: videogamesSelect<ExtArgs> | null
    /**
     * The data needed to update a videogames.
     */
    data: XOR<videogamesUpdateInput, videogamesUncheckedUpdateInput>
    /**
     * Choose, which videogames to update.
     */
    where: videogamesWhereUniqueInput
  }

  /**
   * videogames updateMany
   */
  export type videogamesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update videogames.
     */
    data: XOR<videogamesUpdateManyMutationInput, videogamesUncheckedUpdateManyInput>
    /**
     * Filter which videogames to update
     */
    where?: videogamesWhereInput
  }

  /**
   * videogames upsert
   */
  export type videogamesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videogames
     */
    select?: videogamesSelect<ExtArgs> | null
    /**
     * The filter to search for the videogames to update in case it exists.
     */
    where: videogamesWhereUniqueInput
    /**
     * In case the videogames found by the `where` argument doesn't exist, create a new videogames with this data.
     */
    create: XOR<videogamesCreateInput, videogamesUncheckedCreateInput>
    /**
     * In case the videogames was found with the provided `where` argument, update it with this data.
     */
    update: XOR<videogamesUpdateInput, videogamesUncheckedUpdateInput>
  }

  /**
   * videogames delete
   */
  export type videogamesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videogames
     */
    select?: videogamesSelect<ExtArgs> | null
    /**
     * Filter which videogames to delete.
     */
    where: videogamesWhereUniqueInput
  }

  /**
   * videogames deleteMany
   */
  export type videogamesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which videogames to delete
     */
    where?: videogamesWhereInput
  }

  /**
   * videogames without action
   */
  export type videogamesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the videogames
     */
    select?: videogamesSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AnimeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    mediaimage: 'mediaimage',
    numepisodes: 'numepisodes',
    createdon: 'createdon'
  };

  export type AnimeScalarFieldEnum = (typeof AnimeScalarFieldEnum)[keyof typeof AnimeScalarFieldEnum]


  export const FollowsScalarFieldEnum: {
    followeremail: 'followeremail',
    followingemail: 'followingemail'
  };

  export type FollowsScalarFieldEnum = (typeof FollowsScalarFieldEnum)[keyof typeof FollowsScalarFieldEnum]


  export const GroupmembersScalarFieldEnum: {
    email: 'email',
    gid: 'gid'
  };

  export type GroupmembersScalarFieldEnum = (typeof GroupmembersScalarFieldEnum)[keyof typeof GroupmembersScalarFieldEnum]


  export const GroupsScalarFieldEnum: {
    gid: 'gid',
    groupname: 'groupname',
    ownedby: 'ownedby'
  };

  export type GroupsScalarFieldEnum = (typeof GroupsScalarFieldEnum)[keyof typeof GroupsScalarFieldEnum]


  export const LikesScalarFieldEnum: {
    likeremail: 'likeremail',
    likingemail: 'likingemail',
    listname: 'listname'
  };

  export type LikesScalarFieldEnum = (typeof LikesScalarFieldEnum)[keyof typeof LikesScalarFieldEnum]


  export const ListitemsScalarFieldEnum: {
    email: 'email',
    listname: 'listname',
    rankinginlist: 'rankinginlist',
    itemid: 'itemid'
  };

  export type ListitemsScalarFieldEnum = (typeof ListitemsScalarFieldEnum)[keyof typeof ListitemsScalarFieldEnum]


  export const ListsScalarFieldEnum: {
    email: 'email',
    listname: 'listname',
    listtype: 'listtype'
  };

  export type ListsScalarFieldEnum = (typeof ListsScalarFieldEnum)[keyof typeof ListsScalarFieldEnum]


  export const MoviesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    mediaimage: 'mediaimage',
    createdon: 'createdon'
  };

  export type MoviesScalarFieldEnum = (typeof MoviesScalarFieldEnum)[keyof typeof MoviesScalarFieldEnum]


  export const SongsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    author: 'author',
    album: 'album',
    mediaimage: 'mediaimage',
    createdon: 'createdon'
  };

  export type SongsScalarFieldEnum = (typeof SongsScalarFieldEnum)[keyof typeof SongsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    email: 'email',
    displayname: 'displayname',
    userpassword: 'userpassword',
    createdat: 'createdat'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const VideogamesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    mediaimage: 'mediaimage',
    console: 'console',
    createdon: 'createdon'
  };

  export type VideogamesScalarFieldEnum = (typeof VideogamesScalarFieldEnum)[keyof typeof VideogamesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'listtype'
   */
  export type EnumlisttypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'listtype'>
    


  /**
   * Reference to a field of type 'listtype[]'
   */
  export type ListEnumlisttypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'listtype[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type animeWhereInput = {
    AND?: animeWhereInput | animeWhereInput[]
    OR?: animeWhereInput[]
    NOT?: animeWhereInput | animeWhereInput[]
    id?: IntFilter<"anime"> | number
    title?: StringFilter<"anime"> | string
    mediaimage?: StringNullableFilter<"anime"> | string | null
    numepisodes?: IntNullableFilter<"anime"> | number | null
    createdon?: DateTimeNullableFilter<"anime"> | Date | string | null
  }

  export type animeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    mediaimage?: SortOrderInput | SortOrder
    numepisodes?: SortOrderInput | SortOrder
    createdon?: SortOrderInput | SortOrder
  }

  export type animeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: animeWhereInput | animeWhereInput[]
    OR?: animeWhereInput[]
    NOT?: animeWhereInput | animeWhereInput[]
    title?: StringFilter<"anime"> | string
    mediaimage?: StringNullableFilter<"anime"> | string | null
    numepisodes?: IntNullableFilter<"anime"> | number | null
    createdon?: DateTimeNullableFilter<"anime"> | Date | string | null
  }, "id">

  export type animeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    mediaimage?: SortOrderInput | SortOrder
    numepisodes?: SortOrderInput | SortOrder
    createdon?: SortOrderInput | SortOrder
    _count?: animeCountOrderByAggregateInput
    _avg?: animeAvgOrderByAggregateInput
    _max?: animeMaxOrderByAggregateInput
    _min?: animeMinOrderByAggregateInput
    _sum?: animeSumOrderByAggregateInput
  }

  export type animeScalarWhereWithAggregatesInput = {
    AND?: animeScalarWhereWithAggregatesInput | animeScalarWhereWithAggregatesInput[]
    OR?: animeScalarWhereWithAggregatesInput[]
    NOT?: animeScalarWhereWithAggregatesInput | animeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"anime"> | number
    title?: StringWithAggregatesFilter<"anime"> | string
    mediaimage?: StringNullableWithAggregatesFilter<"anime"> | string | null
    numepisodes?: IntNullableWithAggregatesFilter<"anime"> | number | null
    createdon?: DateTimeNullableWithAggregatesFilter<"anime"> | Date | string | null
  }

  export type followsWhereInput = {
    AND?: followsWhereInput | followsWhereInput[]
    OR?: followsWhereInput[]
    NOT?: followsWhereInput | followsWhereInput[]
    followeremail?: StringFilter<"follows"> | string
    followingemail?: StringFilter<"follows"> | string
    users_follows_followeremailTousers?: XOR<UsersRelationFilter, usersWhereInput>
    users_follows_followingemailTousers?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type followsOrderByWithRelationInput = {
    followeremail?: SortOrder
    followingemail?: SortOrder
    users_follows_followeremailTousers?: usersOrderByWithRelationInput
    users_follows_followingemailTousers?: usersOrderByWithRelationInput
  }

  export type followsWhereUniqueInput = Prisma.AtLeast<{
    followeremail_followingemail?: followsFolloweremailFollowingemailCompoundUniqueInput
    AND?: followsWhereInput | followsWhereInput[]
    OR?: followsWhereInput[]
    NOT?: followsWhereInput | followsWhereInput[]
    followeremail?: StringFilter<"follows"> | string
    followingemail?: StringFilter<"follows"> | string
    users_follows_followeremailTousers?: XOR<UsersRelationFilter, usersWhereInput>
    users_follows_followingemailTousers?: XOR<UsersRelationFilter, usersWhereInput>
  }, "followeremail_followingemail">

  export type followsOrderByWithAggregationInput = {
    followeremail?: SortOrder
    followingemail?: SortOrder
    _count?: followsCountOrderByAggregateInput
    _max?: followsMaxOrderByAggregateInput
    _min?: followsMinOrderByAggregateInput
  }

  export type followsScalarWhereWithAggregatesInput = {
    AND?: followsScalarWhereWithAggregatesInput | followsScalarWhereWithAggregatesInput[]
    OR?: followsScalarWhereWithAggregatesInput[]
    NOT?: followsScalarWhereWithAggregatesInput | followsScalarWhereWithAggregatesInput[]
    followeremail?: StringWithAggregatesFilter<"follows"> | string
    followingemail?: StringWithAggregatesFilter<"follows"> | string
  }

  export type groupmembersWhereInput = {
    AND?: groupmembersWhereInput | groupmembersWhereInput[]
    OR?: groupmembersWhereInput[]
    NOT?: groupmembersWhereInput | groupmembersWhereInput[]
    email?: StringFilter<"groupmembers"> | string
    gid?: IntFilter<"groupmembers"> | number
    users?: XOR<UsersRelationFilter, usersWhereInput>
    groups?: XOR<GroupsRelationFilter, groupsWhereInput>
  }

  export type groupmembersOrderByWithRelationInput = {
    email?: SortOrder
    gid?: SortOrder
    users?: usersOrderByWithRelationInput
    groups?: groupsOrderByWithRelationInput
  }

  export type groupmembersWhereUniqueInput = Prisma.AtLeast<{
    email_gid?: groupmembersEmailGidCompoundUniqueInput
    AND?: groupmembersWhereInput | groupmembersWhereInput[]
    OR?: groupmembersWhereInput[]
    NOT?: groupmembersWhereInput | groupmembersWhereInput[]
    email?: StringFilter<"groupmembers"> | string
    gid?: IntFilter<"groupmembers"> | number
    users?: XOR<UsersRelationFilter, usersWhereInput>
    groups?: XOR<GroupsRelationFilter, groupsWhereInput>
  }, "email_gid">

  export type groupmembersOrderByWithAggregationInput = {
    email?: SortOrder
    gid?: SortOrder
    _count?: groupmembersCountOrderByAggregateInput
    _avg?: groupmembersAvgOrderByAggregateInput
    _max?: groupmembersMaxOrderByAggregateInput
    _min?: groupmembersMinOrderByAggregateInput
    _sum?: groupmembersSumOrderByAggregateInput
  }

  export type groupmembersScalarWhereWithAggregatesInput = {
    AND?: groupmembersScalarWhereWithAggregatesInput | groupmembersScalarWhereWithAggregatesInput[]
    OR?: groupmembersScalarWhereWithAggregatesInput[]
    NOT?: groupmembersScalarWhereWithAggregatesInput | groupmembersScalarWhereWithAggregatesInput[]
    email?: StringWithAggregatesFilter<"groupmembers"> | string
    gid?: IntWithAggregatesFilter<"groupmembers"> | number
  }

  export type groupsWhereInput = {
    AND?: groupsWhereInput | groupsWhereInput[]
    OR?: groupsWhereInput[]
    NOT?: groupsWhereInput | groupsWhereInput[]
    gid?: IntFilter<"groups"> | number
    groupname?: StringFilter<"groups"> | string
    ownedby?: StringFilter<"groups"> | string
    groupmembers?: GroupmembersListRelationFilter
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type groupsOrderByWithRelationInput = {
    gid?: SortOrder
    groupname?: SortOrder
    ownedby?: SortOrder
    groupmembers?: groupmembersOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type groupsWhereUniqueInput = Prisma.AtLeast<{
    gid?: number
    AND?: groupsWhereInput | groupsWhereInput[]
    OR?: groupsWhereInput[]
    NOT?: groupsWhereInput | groupsWhereInput[]
    groupname?: StringFilter<"groups"> | string
    ownedby?: StringFilter<"groups"> | string
    groupmembers?: GroupmembersListRelationFilter
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "gid">

  export type groupsOrderByWithAggregationInput = {
    gid?: SortOrder
    groupname?: SortOrder
    ownedby?: SortOrder
    _count?: groupsCountOrderByAggregateInput
    _avg?: groupsAvgOrderByAggregateInput
    _max?: groupsMaxOrderByAggregateInput
    _min?: groupsMinOrderByAggregateInput
    _sum?: groupsSumOrderByAggregateInput
  }

  export type groupsScalarWhereWithAggregatesInput = {
    AND?: groupsScalarWhereWithAggregatesInput | groupsScalarWhereWithAggregatesInput[]
    OR?: groupsScalarWhereWithAggregatesInput[]
    NOT?: groupsScalarWhereWithAggregatesInput | groupsScalarWhereWithAggregatesInput[]
    gid?: IntWithAggregatesFilter<"groups"> | number
    groupname?: StringWithAggregatesFilter<"groups"> | string
    ownedby?: StringWithAggregatesFilter<"groups"> | string
  }

  export type likesWhereInput = {
    AND?: likesWhereInput | likesWhereInput[]
    OR?: likesWhereInput[]
    NOT?: likesWhereInput | likesWhereInput[]
    likeremail?: StringFilter<"likes"> | string
    likingemail?: StringFilter<"likes"> | string
    listname?: StringFilter<"likes"> | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    listitems?: XOR<ListsRelationFilter, listsWhereInput>
  }

  export type likesOrderByWithRelationInput = {
    likeremail?: SortOrder
    likingemail?: SortOrder
    listname?: SortOrder
    users?: usersOrderByWithRelationInput
    listitems?: listsOrderByWithRelationInput
  }

  export type likesWhereUniqueInput = Prisma.AtLeast<{
    likeremail_listname?: likesLikeremailListnameCompoundUniqueInput
    likeremail_likingemail_listname?: likesLikeremailLikingemailListnameCompoundUniqueInput
    AND?: likesWhereInput | likesWhereInput[]
    OR?: likesWhereInput[]
    NOT?: likesWhereInput | likesWhereInput[]
    likeremail?: StringFilter<"likes"> | string
    likingemail?: StringFilter<"likes"> | string
    listname?: StringFilter<"likes"> | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    listitems?: XOR<ListsRelationFilter, listsWhereInput>
  }, "likeremail_likingemail_listname" | "likeremail_listname">

  export type likesOrderByWithAggregationInput = {
    likeremail?: SortOrder
    likingemail?: SortOrder
    listname?: SortOrder
    _count?: likesCountOrderByAggregateInput
    _max?: likesMaxOrderByAggregateInput
    _min?: likesMinOrderByAggregateInput
  }

  export type likesScalarWhereWithAggregatesInput = {
    AND?: likesScalarWhereWithAggregatesInput | likesScalarWhereWithAggregatesInput[]
    OR?: likesScalarWhereWithAggregatesInput[]
    NOT?: likesScalarWhereWithAggregatesInput | likesScalarWhereWithAggregatesInput[]
    likeremail?: StringWithAggregatesFilter<"likes"> | string
    likingemail?: StringWithAggregatesFilter<"likes"> | string
    listname?: StringWithAggregatesFilter<"likes"> | string
  }

  export type listitemsWhereInput = {
    AND?: listitemsWhereInput | listitemsWhereInput[]
    OR?: listitemsWhereInput[]
    NOT?: listitemsWhereInput | listitemsWhereInput[]
    email?: StringFilter<"listitems"> | string
    listname?: StringFilter<"listitems"> | string
    rankinginlist?: IntFilter<"listitems"> | number
    itemid?: IntFilter<"listitems"> | number
    lists?: XOR<ListsRelationFilter, listsWhereInput>
  }

  export type listitemsOrderByWithRelationInput = {
    email?: SortOrder
    listname?: SortOrder
    rankinginlist?: SortOrder
    itemid?: SortOrder
    lists?: listsOrderByWithRelationInput
  }

  export type listitemsWhereUniqueInput = Prisma.AtLeast<{
    email_listname_itemid?: listitemsEmailListnameItemidCompoundUniqueInput
    AND?: listitemsWhereInput | listitemsWhereInput[]
    OR?: listitemsWhereInput[]
    NOT?: listitemsWhereInput | listitemsWhereInput[]
    email?: StringFilter<"listitems"> | string
    listname?: StringFilter<"listitems"> | string
    rankinginlist?: IntFilter<"listitems"> | number
    itemid?: IntFilter<"listitems"> | number
    lists?: XOR<ListsRelationFilter, listsWhereInput>
  }, "email_listname_itemid">

  export type listitemsOrderByWithAggregationInput = {
    email?: SortOrder
    listname?: SortOrder
    rankinginlist?: SortOrder
    itemid?: SortOrder
    _count?: listitemsCountOrderByAggregateInput
    _avg?: listitemsAvgOrderByAggregateInput
    _max?: listitemsMaxOrderByAggregateInput
    _min?: listitemsMinOrderByAggregateInput
    _sum?: listitemsSumOrderByAggregateInput
  }

  export type listitemsScalarWhereWithAggregatesInput = {
    AND?: listitemsScalarWhereWithAggregatesInput | listitemsScalarWhereWithAggregatesInput[]
    OR?: listitemsScalarWhereWithAggregatesInput[]
    NOT?: listitemsScalarWhereWithAggregatesInput | listitemsScalarWhereWithAggregatesInput[]
    email?: StringWithAggregatesFilter<"listitems"> | string
    listname?: StringWithAggregatesFilter<"listitems"> | string
    rankinginlist?: IntWithAggregatesFilter<"listitems"> | number
    itemid?: IntWithAggregatesFilter<"listitems"> | number
  }

  export type listsWhereInput = {
    AND?: listsWhereInput | listsWhereInput[]
    OR?: listsWhereInput[]
    NOT?: listsWhereInput | listsWhereInput[]
    email?: StringFilter<"lists"> | string
    listname?: StringFilter<"lists"> | string
    listtype?: EnumlisttypeFilter<"lists"> | $Enums.listtype
    likes?: LikesListRelationFilter
    listitems?: ListitemsListRelationFilter
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type listsOrderByWithRelationInput = {
    email?: SortOrder
    listname?: SortOrder
    listtype?: SortOrder
    likes?: likesOrderByRelationAggregateInput
    listitems?: listitemsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type listsWhereUniqueInput = Prisma.AtLeast<{
    email_listname?: listsEmailListnameCompoundUniqueInput
    AND?: listsWhereInput | listsWhereInput[]
    OR?: listsWhereInput[]
    NOT?: listsWhereInput | listsWhereInput[]
    email?: StringFilter<"lists"> | string
    listname?: StringFilter<"lists"> | string
    listtype?: EnumlisttypeFilter<"lists"> | $Enums.listtype
    likes?: LikesListRelationFilter
    listitems?: ListitemsListRelationFilter
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "email_listname">

  export type listsOrderByWithAggregationInput = {
    email?: SortOrder
    listname?: SortOrder
    listtype?: SortOrder
    _count?: listsCountOrderByAggregateInput
    _max?: listsMaxOrderByAggregateInput
    _min?: listsMinOrderByAggregateInput
  }

  export type listsScalarWhereWithAggregatesInput = {
    AND?: listsScalarWhereWithAggregatesInput | listsScalarWhereWithAggregatesInput[]
    OR?: listsScalarWhereWithAggregatesInput[]
    NOT?: listsScalarWhereWithAggregatesInput | listsScalarWhereWithAggregatesInput[]
    email?: StringWithAggregatesFilter<"lists"> | string
    listname?: StringWithAggregatesFilter<"lists"> | string
    listtype?: EnumlisttypeWithAggregatesFilter<"lists"> | $Enums.listtype
  }

  export type moviesWhereInput = {
    AND?: moviesWhereInput | moviesWhereInput[]
    OR?: moviesWhereInput[]
    NOT?: moviesWhereInput | moviesWhereInput[]
    id?: IntFilter<"movies"> | number
    title?: StringFilter<"movies"> | string
    mediaimage?: StringNullableFilter<"movies"> | string | null
    createdon?: DateTimeNullableFilter<"movies"> | Date | string | null
  }

  export type moviesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    mediaimage?: SortOrderInput | SortOrder
    createdon?: SortOrderInput | SortOrder
  }

  export type moviesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: moviesWhereInput | moviesWhereInput[]
    OR?: moviesWhereInput[]
    NOT?: moviesWhereInput | moviesWhereInput[]
    title?: StringFilter<"movies"> | string
    mediaimage?: StringNullableFilter<"movies"> | string | null
    createdon?: DateTimeNullableFilter<"movies"> | Date | string | null
  }, "id">

  export type moviesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    mediaimage?: SortOrderInput | SortOrder
    createdon?: SortOrderInput | SortOrder
    _count?: moviesCountOrderByAggregateInput
    _avg?: moviesAvgOrderByAggregateInput
    _max?: moviesMaxOrderByAggregateInput
    _min?: moviesMinOrderByAggregateInput
    _sum?: moviesSumOrderByAggregateInput
  }

  export type moviesScalarWhereWithAggregatesInput = {
    AND?: moviesScalarWhereWithAggregatesInput | moviesScalarWhereWithAggregatesInput[]
    OR?: moviesScalarWhereWithAggregatesInput[]
    NOT?: moviesScalarWhereWithAggregatesInput | moviesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"movies"> | number
    title?: StringWithAggregatesFilter<"movies"> | string
    mediaimage?: StringNullableWithAggregatesFilter<"movies"> | string | null
    createdon?: DateTimeNullableWithAggregatesFilter<"movies"> | Date | string | null
  }

  export type songsWhereInput = {
    AND?: songsWhereInput | songsWhereInput[]
    OR?: songsWhereInput[]
    NOT?: songsWhereInput | songsWhereInput[]
    id?: IntFilter<"songs"> | number
    title?: StringFilter<"songs"> | string
    author?: StringNullableFilter<"songs"> | string | null
    album?: StringNullableFilter<"songs"> | string | null
    mediaimage?: StringNullableFilter<"songs"> | string | null
    createdon?: DateTimeNullableFilter<"songs"> | Date | string | null
  }

  export type songsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrderInput | SortOrder
    album?: SortOrderInput | SortOrder
    mediaimage?: SortOrderInput | SortOrder
    createdon?: SortOrderInput | SortOrder
  }

  export type songsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: songsWhereInput | songsWhereInput[]
    OR?: songsWhereInput[]
    NOT?: songsWhereInput | songsWhereInput[]
    title?: StringFilter<"songs"> | string
    author?: StringNullableFilter<"songs"> | string | null
    album?: StringNullableFilter<"songs"> | string | null
    mediaimage?: StringNullableFilter<"songs"> | string | null
    createdon?: DateTimeNullableFilter<"songs"> | Date | string | null
  }, "id">

  export type songsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrderInput | SortOrder
    album?: SortOrderInput | SortOrder
    mediaimage?: SortOrderInput | SortOrder
    createdon?: SortOrderInput | SortOrder
    _count?: songsCountOrderByAggregateInput
    _avg?: songsAvgOrderByAggregateInput
    _max?: songsMaxOrderByAggregateInput
    _min?: songsMinOrderByAggregateInput
    _sum?: songsSumOrderByAggregateInput
  }

  export type songsScalarWhereWithAggregatesInput = {
    AND?: songsScalarWhereWithAggregatesInput | songsScalarWhereWithAggregatesInput[]
    OR?: songsScalarWhereWithAggregatesInput[]
    NOT?: songsScalarWhereWithAggregatesInput | songsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"songs"> | number
    title?: StringWithAggregatesFilter<"songs"> | string
    author?: StringNullableWithAggregatesFilter<"songs"> | string | null
    album?: StringNullableWithAggregatesFilter<"songs"> | string | null
    mediaimage?: StringNullableWithAggregatesFilter<"songs"> | string | null
    createdon?: DateTimeNullableWithAggregatesFilter<"songs"> | Date | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    email?: StringFilter<"users"> | string
    displayname?: StringFilter<"users"> | string
    userpassword?: StringFilter<"users"> | string
    createdat?: DateTimeNullableFilter<"users"> | Date | string | null
    follows_follows_followeremailTousers?: FollowsListRelationFilter
    follows_follows_followingemailTousers?: FollowsListRelationFilter
    groupmembers?: GroupmembersListRelationFilter
    groups?: GroupsListRelationFilter
    likes?: LikesListRelationFilter
    lists?: ListsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    email?: SortOrder
    displayname?: SortOrder
    userpassword?: SortOrder
    createdat?: SortOrderInput | SortOrder
    follows_follows_followeremailTousers?: followsOrderByRelationAggregateInput
    follows_follows_followingemailTousers?: followsOrderByRelationAggregateInput
    groupmembers?: groupmembersOrderByRelationAggregateInput
    groups?: groupsOrderByRelationAggregateInput
    likes?: likesOrderByRelationAggregateInput
    lists?: listsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    displayname?: StringFilter<"users"> | string
    userpassword?: StringFilter<"users"> | string
    createdat?: DateTimeNullableFilter<"users"> | Date | string | null
    follows_follows_followeremailTousers?: FollowsListRelationFilter
    follows_follows_followingemailTousers?: FollowsListRelationFilter
    groupmembers?: GroupmembersListRelationFilter
    groups?: GroupsListRelationFilter
    likes?: LikesListRelationFilter
    lists?: ListsListRelationFilter
  }, "email">

  export type usersOrderByWithAggregationInput = {
    email?: SortOrder
    displayname?: SortOrder
    userpassword?: SortOrder
    createdat?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    email?: StringWithAggregatesFilter<"users"> | string
    displayname?: StringWithAggregatesFilter<"users"> | string
    userpassword?: StringWithAggregatesFilter<"users"> | string
    createdat?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type videogamesWhereInput = {
    AND?: videogamesWhereInput | videogamesWhereInput[]
    OR?: videogamesWhereInput[]
    NOT?: videogamesWhereInput | videogamesWhereInput[]
    id?: IntFilter<"videogames"> | number
    title?: StringFilter<"videogames"> | string
    mediaimage?: StringNullableFilter<"videogames"> | string | null
    console?: StringNullableFilter<"videogames"> | string | null
    createdon?: DateTimeNullableFilter<"videogames"> | Date | string | null
  }

  export type videogamesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    mediaimage?: SortOrderInput | SortOrder
    console?: SortOrderInput | SortOrder
    createdon?: SortOrderInput | SortOrder
  }

  export type videogamesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: videogamesWhereInput | videogamesWhereInput[]
    OR?: videogamesWhereInput[]
    NOT?: videogamesWhereInput | videogamesWhereInput[]
    title?: StringFilter<"videogames"> | string
    mediaimage?: StringNullableFilter<"videogames"> | string | null
    console?: StringNullableFilter<"videogames"> | string | null
    createdon?: DateTimeNullableFilter<"videogames"> | Date | string | null
  }, "id">

  export type videogamesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    mediaimage?: SortOrderInput | SortOrder
    console?: SortOrderInput | SortOrder
    createdon?: SortOrderInput | SortOrder
    _count?: videogamesCountOrderByAggregateInput
    _avg?: videogamesAvgOrderByAggregateInput
    _max?: videogamesMaxOrderByAggregateInput
    _min?: videogamesMinOrderByAggregateInput
    _sum?: videogamesSumOrderByAggregateInput
  }

  export type videogamesScalarWhereWithAggregatesInput = {
    AND?: videogamesScalarWhereWithAggregatesInput | videogamesScalarWhereWithAggregatesInput[]
    OR?: videogamesScalarWhereWithAggregatesInput[]
    NOT?: videogamesScalarWhereWithAggregatesInput | videogamesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"videogames"> | number
    title?: StringWithAggregatesFilter<"videogames"> | string
    mediaimage?: StringNullableWithAggregatesFilter<"videogames"> | string | null
    console?: StringNullableWithAggregatesFilter<"videogames"> | string | null
    createdon?: DateTimeNullableWithAggregatesFilter<"videogames"> | Date | string | null
  }

  export type animeCreateInput = {
    title: string
    mediaimage?: string | null
    numepisodes?: number | null
    createdon?: Date | string | null
  }

  export type animeUncheckedCreateInput = {
    id?: number
    title: string
    mediaimage?: string | null
    numepisodes?: number | null
    createdon?: Date | string | null
  }

  export type animeUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    numepisodes?: NullableIntFieldUpdateOperationsInput | number | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type animeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    numepisodes?: NullableIntFieldUpdateOperationsInput | number | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type animeCreateManyInput = {
    id?: number
    title: string
    mediaimage?: string | null
    numepisodes?: number | null
    createdon?: Date | string | null
  }

  export type animeUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    numepisodes?: NullableIntFieldUpdateOperationsInput | number | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type animeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    numepisodes?: NullableIntFieldUpdateOperationsInput | number | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type followsCreateInput = {
    users_follows_followeremailTousers: usersCreateNestedOneWithoutFollows_follows_followeremailTousersInput
    users_follows_followingemailTousers: usersCreateNestedOneWithoutFollows_follows_followingemailTousersInput
  }

  export type followsUncheckedCreateInput = {
    followeremail: string
    followingemail: string
  }

  export type followsUpdateInput = {
    users_follows_followeremailTousers?: usersUpdateOneRequiredWithoutFollows_follows_followeremailTousersNestedInput
    users_follows_followingemailTousers?: usersUpdateOneRequiredWithoutFollows_follows_followingemailTousersNestedInput
  }

  export type followsUncheckedUpdateInput = {
    followeremail?: StringFieldUpdateOperationsInput | string
    followingemail?: StringFieldUpdateOperationsInput | string
  }

  export type followsCreateManyInput = {
    followeremail: string
    followingemail: string
  }

  export type followsUpdateManyMutationInput = {

  }

  export type followsUncheckedUpdateManyInput = {
    followeremail?: StringFieldUpdateOperationsInput | string
    followingemail?: StringFieldUpdateOperationsInput | string
  }

  export type groupmembersCreateInput = {
    users: usersCreateNestedOneWithoutGroupmembersInput
    groups: groupsCreateNestedOneWithoutGroupmembersInput
  }

  export type groupmembersUncheckedCreateInput = {
    email: string
    gid: number
  }

  export type groupmembersUpdateInput = {
    users?: usersUpdateOneRequiredWithoutGroupmembersNestedInput
    groups?: groupsUpdateOneRequiredWithoutGroupmembersNestedInput
  }

  export type groupmembersUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    gid?: IntFieldUpdateOperationsInput | number
  }

  export type groupmembersCreateManyInput = {
    email: string
    gid: number
  }

  export type groupmembersUpdateManyMutationInput = {

  }

  export type groupmembersUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    gid?: IntFieldUpdateOperationsInput | number
  }

  export type groupsCreateInput = {
    groupname: string
    groupmembers?: groupmembersCreateNestedManyWithoutGroupsInput
    users: usersCreateNestedOneWithoutGroupsInput
  }

  export type groupsUncheckedCreateInput = {
    gid?: number
    groupname: string
    ownedby: string
    groupmembers?: groupmembersUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type groupsUpdateInput = {
    groupname?: StringFieldUpdateOperationsInput | string
    groupmembers?: groupmembersUpdateManyWithoutGroupsNestedInput
    users?: usersUpdateOneRequiredWithoutGroupsNestedInput
  }

  export type groupsUncheckedUpdateInput = {
    gid?: IntFieldUpdateOperationsInput | number
    groupname?: StringFieldUpdateOperationsInput | string
    ownedby?: StringFieldUpdateOperationsInput | string
    groupmembers?: groupmembersUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type groupsCreateManyInput = {
    gid?: number
    groupname: string
    ownedby: string
  }

  export type groupsUpdateManyMutationInput = {
    groupname?: StringFieldUpdateOperationsInput | string
  }

  export type groupsUncheckedUpdateManyInput = {
    gid?: IntFieldUpdateOperationsInput | number
    groupname?: StringFieldUpdateOperationsInput | string
    ownedby?: StringFieldUpdateOperationsInput | string
  }

  export type likesCreateInput = {
    users: usersCreateNestedOneWithoutLikesInput
    listitems: listsCreateNestedOneWithoutLikesInput
  }

  export type likesUncheckedCreateInput = {
    likeremail: string
    likingemail: string
    listname: string
  }

  export type likesUpdateInput = {
    users?: usersUpdateOneRequiredWithoutLikesNestedInput
    listitems?: listsUpdateOneRequiredWithoutLikesNestedInput
  }

  export type likesUncheckedUpdateInput = {
    likeremail?: StringFieldUpdateOperationsInput | string
    likingemail?: StringFieldUpdateOperationsInput | string
    listname?: StringFieldUpdateOperationsInput | string
  }

  export type likesCreateManyInput = {
    likeremail: string
    likingemail: string
    listname: string
  }

  export type likesUpdateManyMutationInput = {

  }

  export type likesUncheckedUpdateManyInput = {
    likeremail?: StringFieldUpdateOperationsInput | string
    likingemail?: StringFieldUpdateOperationsInput | string
    listname?: StringFieldUpdateOperationsInput | string
  }

  export type listitemsCreateInput = {
    rankinginlist: number
    itemid: number
    lists: listsCreateNestedOneWithoutListitemsInput
  }

  export type listitemsUncheckedCreateInput = {
    email: string
    listname: string
    rankinginlist: number
    itemid: number
  }

  export type listitemsUpdateInput = {
    rankinginlist?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
    lists?: listsUpdateOneRequiredWithoutListitemsNestedInput
  }

  export type listitemsUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    listname?: StringFieldUpdateOperationsInput | string
    rankinginlist?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
  }

  export type listitemsCreateManyInput = {
    email: string
    listname: string
    rankinginlist: number
    itemid: number
  }

  export type listitemsUpdateManyMutationInput = {
    rankinginlist?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
  }

  export type listitemsUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    listname?: StringFieldUpdateOperationsInput | string
    rankinginlist?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
  }

  export type listsCreateInput = {
    listname: string
    listtype: $Enums.listtype
    likes?: likesCreateNestedManyWithoutListitemsInput
    listitems?: listitemsCreateNestedManyWithoutListsInput
    users: usersCreateNestedOneWithoutListsInput
  }

  export type listsUncheckedCreateInput = {
    email: string
    listname: string
    listtype: $Enums.listtype
    likes?: likesUncheckedCreateNestedManyWithoutListitemsInput
    listitems?: listitemsUncheckedCreateNestedManyWithoutListsInput
  }

  export type listsUpdateInput = {
    listname?: StringFieldUpdateOperationsInput | string
    listtype?: EnumlisttypeFieldUpdateOperationsInput | $Enums.listtype
    likes?: likesUpdateManyWithoutListitemsNestedInput
    listitems?: listitemsUpdateManyWithoutListsNestedInput
    users?: usersUpdateOneRequiredWithoutListsNestedInput
  }

  export type listsUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    listname?: StringFieldUpdateOperationsInput | string
    listtype?: EnumlisttypeFieldUpdateOperationsInput | $Enums.listtype
    likes?: likesUncheckedUpdateManyWithoutListitemsNestedInput
    listitems?: listitemsUncheckedUpdateManyWithoutListsNestedInput
  }

  export type listsCreateManyInput = {
    email: string
    listname: string
    listtype: $Enums.listtype
  }

  export type listsUpdateManyMutationInput = {
    listname?: StringFieldUpdateOperationsInput | string
    listtype?: EnumlisttypeFieldUpdateOperationsInput | $Enums.listtype
  }

  export type listsUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    listname?: StringFieldUpdateOperationsInput | string
    listtype?: EnumlisttypeFieldUpdateOperationsInput | $Enums.listtype
  }

  export type moviesCreateInput = {
    title: string
    mediaimage?: string | null
    createdon?: Date | string | null
  }

  export type moviesUncheckedCreateInput = {
    id?: number
    title: string
    mediaimage?: string | null
    createdon?: Date | string | null
  }

  export type moviesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type moviesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type moviesCreateManyInput = {
    id?: number
    title: string
    mediaimage?: string | null
    createdon?: Date | string | null
  }

  export type moviesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type moviesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type songsCreateInput = {
    title: string
    author?: string | null
    album?: string | null
    mediaimage?: string | null
    createdon?: Date | string | null
  }

  export type songsUncheckedCreateInput = {
    id?: number
    title: string
    author?: string | null
    album?: string | null
    mediaimage?: string | null
    createdon?: Date | string | null
  }

  export type songsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    album?: NullableStringFieldUpdateOperationsInput | string | null
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type songsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    album?: NullableStringFieldUpdateOperationsInput | string | null
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type songsCreateManyInput = {
    id?: number
    title: string
    author?: string | null
    album?: string | null
    mediaimage?: string | null
    createdon?: Date | string | null
  }

  export type songsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    album?: NullableStringFieldUpdateOperationsInput | string | null
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type songsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    album?: NullableStringFieldUpdateOperationsInput | string | null
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    email: string
    displayname: string
    userpassword: string
    createdat?: Date | string | null
    follows_follows_followeremailTousers?: followsCreateNestedManyWithoutUsers_follows_followeremailTousersInput
    follows_follows_followingemailTousers?: followsCreateNestedManyWithoutUsers_follows_followingemailTousersInput
    groupmembers?: groupmembersCreateNestedManyWithoutUsersInput
    groups?: groupsCreateNestedManyWithoutUsersInput
    likes?: likesCreateNestedManyWithoutUsersInput
    lists?: listsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    email: string
    displayname: string
    userpassword: string
    createdat?: Date | string | null
    follows_follows_followeremailTousers?: followsUncheckedCreateNestedManyWithoutUsers_follows_followeremailTousersInput
    follows_follows_followingemailTousers?: followsUncheckedCreateNestedManyWithoutUsers_follows_followingemailTousersInput
    groupmembers?: groupmembersUncheckedCreateNestedManyWithoutUsersInput
    groups?: groupsUncheckedCreateNestedManyWithoutUsersInput
    likes?: likesUncheckedCreateNestedManyWithoutUsersInput
    lists?: listsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follows_follows_followeremailTousers?: followsUpdateManyWithoutUsers_follows_followeremailTousersNestedInput
    follows_follows_followingemailTousers?: followsUpdateManyWithoutUsers_follows_followingemailTousersNestedInput
    groupmembers?: groupmembersUpdateManyWithoutUsersNestedInput
    groups?: groupsUpdateManyWithoutUsersNestedInput
    likes?: likesUpdateManyWithoutUsersNestedInput
    lists?: listsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follows_follows_followeremailTousers?: followsUncheckedUpdateManyWithoutUsers_follows_followeremailTousersNestedInput
    follows_follows_followingemailTousers?: followsUncheckedUpdateManyWithoutUsers_follows_followingemailTousersNestedInput
    groupmembers?: groupmembersUncheckedUpdateManyWithoutUsersNestedInput
    groups?: groupsUncheckedUpdateManyWithoutUsersNestedInput
    likes?: likesUncheckedUpdateManyWithoutUsersNestedInput
    lists?: listsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    email: string
    displayname: string
    userpassword: string
    createdat?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videogamesCreateInput = {
    title: string
    mediaimage?: string | null
    console?: string | null
    createdon?: Date | string | null
  }

  export type videogamesUncheckedCreateInput = {
    id?: number
    title: string
    mediaimage?: string | null
    console?: string | null
    createdon?: Date | string | null
  }

  export type videogamesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    console?: NullableStringFieldUpdateOperationsInput | string | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videogamesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    console?: NullableStringFieldUpdateOperationsInput | string | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videogamesCreateManyInput = {
    id?: number
    title: string
    mediaimage?: string | null
    console?: string | null
    createdon?: Date | string | null
  }

  export type videogamesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    console?: NullableStringFieldUpdateOperationsInput | string | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type videogamesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    mediaimage?: NullableStringFieldUpdateOperationsInput | string | null
    console?: NullableStringFieldUpdateOperationsInput | string | null
    createdon?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type animeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    mediaimage?: SortOrder
    numepisodes?: SortOrder
    createdon?: SortOrder
  }

  export type animeAvgOrderByAggregateInput = {
    id?: SortOrder
    numepisodes?: SortOrder
  }

  export type animeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    mediaimage?: SortOrder
    numepisodes?: SortOrder
    createdon?: SortOrder
  }

  export type animeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    mediaimage?: SortOrder
    numepisodes?: SortOrder
    createdon?: SortOrder
  }

  export type animeSumOrderByAggregateInput = {
    id?: SortOrder
    numepisodes?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type followsFolloweremailFollowingemailCompoundUniqueInput = {
    followeremail: string
    followingemail: string
  }

  export type followsCountOrderByAggregateInput = {
    followeremail?: SortOrder
    followingemail?: SortOrder
  }

  export type followsMaxOrderByAggregateInput = {
    followeremail?: SortOrder
    followingemail?: SortOrder
  }

  export type followsMinOrderByAggregateInput = {
    followeremail?: SortOrder
    followingemail?: SortOrder
  }

  export type GroupsRelationFilter = {
    is?: groupsWhereInput
    isNot?: groupsWhereInput
  }

  export type groupmembersEmailGidCompoundUniqueInput = {
    email: string
    gid: number
  }

  export type groupmembersCountOrderByAggregateInput = {
    email?: SortOrder
    gid?: SortOrder
  }

  export type groupmembersAvgOrderByAggregateInput = {
    gid?: SortOrder
  }

  export type groupmembersMaxOrderByAggregateInput = {
    email?: SortOrder
    gid?: SortOrder
  }

  export type groupmembersMinOrderByAggregateInput = {
    email?: SortOrder
    gid?: SortOrder
  }

  export type groupmembersSumOrderByAggregateInput = {
    gid?: SortOrder
  }

  export type GroupmembersListRelationFilter = {
    every?: groupmembersWhereInput
    some?: groupmembersWhereInput
    none?: groupmembersWhereInput
  }

  export type groupmembersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type groupsCountOrderByAggregateInput = {
    gid?: SortOrder
    groupname?: SortOrder
    ownedby?: SortOrder
  }

  export type groupsAvgOrderByAggregateInput = {
    gid?: SortOrder
  }

  export type groupsMaxOrderByAggregateInput = {
    gid?: SortOrder
    groupname?: SortOrder
    ownedby?: SortOrder
  }

  export type groupsMinOrderByAggregateInput = {
    gid?: SortOrder
    groupname?: SortOrder
    ownedby?: SortOrder
  }

  export type groupsSumOrderByAggregateInput = {
    gid?: SortOrder
  }

  export type ListsRelationFilter = {
    is?: listsWhereInput
    isNot?: listsWhereInput
  }

  export type likesLikeremailListnameCompoundUniqueInput = {
    likeremail: string
    listname: string
  }

  export type likesLikeremailLikingemailListnameCompoundUniqueInput = {
    likeremail: string
    likingemail: string
    listname: string
  }

  export type likesCountOrderByAggregateInput = {
    likeremail?: SortOrder
    likingemail?: SortOrder
    listname?: SortOrder
  }

  export type likesMaxOrderByAggregateInput = {
    likeremail?: SortOrder
    likingemail?: SortOrder
    listname?: SortOrder
  }

  export type likesMinOrderByAggregateInput = {
    likeremail?: SortOrder
    likingemail?: SortOrder
    listname?: SortOrder
  }

  export type listitemsEmailListnameItemidCompoundUniqueInput = {
    email: string
    listname: string
    itemid: number
  }

  export type listitemsCountOrderByAggregateInput = {
    email?: SortOrder
    listname?: SortOrder
    rankinginlist?: SortOrder
    itemid?: SortOrder
  }

  export type listitemsAvgOrderByAggregateInput = {
    rankinginlist?: SortOrder
    itemid?: SortOrder
  }

  export type listitemsMaxOrderByAggregateInput = {
    email?: SortOrder
    listname?: SortOrder
    rankinginlist?: SortOrder
    itemid?: SortOrder
  }

  export type listitemsMinOrderByAggregateInput = {
    email?: SortOrder
    listname?: SortOrder
    rankinginlist?: SortOrder
    itemid?: SortOrder
  }

  export type listitemsSumOrderByAggregateInput = {
    rankinginlist?: SortOrder
    itemid?: SortOrder
  }

  export type EnumlisttypeFilter<$PrismaModel = never> = {
    equals?: $Enums.listtype | EnumlisttypeFieldRefInput<$PrismaModel>
    in?: $Enums.listtype[] | ListEnumlisttypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.listtype[] | ListEnumlisttypeFieldRefInput<$PrismaModel>
    not?: NestedEnumlisttypeFilter<$PrismaModel> | $Enums.listtype
  }

  export type LikesListRelationFilter = {
    every?: likesWhereInput
    some?: likesWhereInput
    none?: likesWhereInput
  }

  export type ListitemsListRelationFilter = {
    every?: listitemsWhereInput
    some?: listitemsWhereInput
    none?: listitemsWhereInput
  }

  export type likesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type listitemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type listsEmailListnameCompoundUniqueInput = {
    email: string
    listname: string
  }

  export type listsCountOrderByAggregateInput = {
    email?: SortOrder
    listname?: SortOrder
    listtype?: SortOrder
  }

  export type listsMaxOrderByAggregateInput = {
    email?: SortOrder
    listname?: SortOrder
    listtype?: SortOrder
  }

  export type listsMinOrderByAggregateInput = {
    email?: SortOrder
    listname?: SortOrder
    listtype?: SortOrder
  }

  export type EnumlisttypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.listtype | EnumlisttypeFieldRefInput<$PrismaModel>
    in?: $Enums.listtype[] | ListEnumlisttypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.listtype[] | ListEnumlisttypeFieldRefInput<$PrismaModel>
    not?: NestedEnumlisttypeWithAggregatesFilter<$PrismaModel> | $Enums.listtype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumlisttypeFilter<$PrismaModel>
    _max?: NestedEnumlisttypeFilter<$PrismaModel>
  }

  export type moviesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    mediaimage?: SortOrder
    createdon?: SortOrder
  }

  export type moviesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type moviesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    mediaimage?: SortOrder
    createdon?: SortOrder
  }

  export type moviesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    mediaimage?: SortOrder
    createdon?: SortOrder
  }

  export type moviesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type songsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    album?: SortOrder
    mediaimage?: SortOrder
    createdon?: SortOrder
  }

  export type songsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type songsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    album?: SortOrder
    mediaimage?: SortOrder
    createdon?: SortOrder
  }

  export type songsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    author?: SortOrder
    album?: SortOrder
    mediaimage?: SortOrder
    createdon?: SortOrder
  }

  export type songsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FollowsListRelationFilter = {
    every?: followsWhereInput
    some?: followsWhereInput
    none?: followsWhereInput
  }

  export type GroupsListRelationFilter = {
    every?: groupsWhereInput
    some?: groupsWhereInput
    none?: groupsWhereInput
  }

  export type ListsListRelationFilter = {
    every?: listsWhereInput
    some?: listsWhereInput
    none?: listsWhereInput
  }

  export type followsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type groupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type listsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    email?: SortOrder
    displayname?: SortOrder
    userpassword?: SortOrder
    createdat?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    email?: SortOrder
    displayname?: SortOrder
    userpassword?: SortOrder
    createdat?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    email?: SortOrder
    displayname?: SortOrder
    userpassword?: SortOrder
    createdat?: SortOrder
  }

  export type videogamesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    mediaimage?: SortOrder
    console?: SortOrder
    createdon?: SortOrder
  }

  export type videogamesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type videogamesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    mediaimage?: SortOrder
    console?: SortOrder
    createdon?: SortOrder
  }

  export type videogamesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    mediaimage?: SortOrder
    console?: SortOrder
    createdon?: SortOrder
  }

  export type videogamesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usersCreateNestedOneWithoutFollows_follows_followeremailTousersInput = {
    create?: XOR<usersCreateWithoutFollows_follows_followeremailTousersInput, usersUncheckedCreateWithoutFollows_follows_followeremailTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFollows_follows_followeremailTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutFollows_follows_followingemailTousersInput = {
    create?: XOR<usersCreateWithoutFollows_follows_followingemailTousersInput, usersUncheckedCreateWithoutFollows_follows_followingemailTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFollows_follows_followingemailTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutFollows_follows_followeremailTousersNestedInput = {
    create?: XOR<usersCreateWithoutFollows_follows_followeremailTousersInput, usersUncheckedCreateWithoutFollows_follows_followeremailTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFollows_follows_followeremailTousersInput
    upsert?: usersUpsertWithoutFollows_follows_followeremailTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFollows_follows_followeremailTousersInput, usersUpdateWithoutFollows_follows_followeremailTousersInput>, usersUncheckedUpdateWithoutFollows_follows_followeremailTousersInput>
  }

  export type usersUpdateOneRequiredWithoutFollows_follows_followingemailTousersNestedInput = {
    create?: XOR<usersCreateWithoutFollows_follows_followingemailTousersInput, usersUncheckedCreateWithoutFollows_follows_followingemailTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutFollows_follows_followingemailTousersInput
    upsert?: usersUpsertWithoutFollows_follows_followingemailTousersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFollows_follows_followingemailTousersInput, usersUpdateWithoutFollows_follows_followingemailTousersInput>, usersUncheckedUpdateWithoutFollows_follows_followingemailTousersInput>
  }

  export type usersCreateNestedOneWithoutGroupmembersInput = {
    create?: XOR<usersCreateWithoutGroupmembersInput, usersUncheckedCreateWithoutGroupmembersInput>
    connectOrCreate?: usersCreateOrConnectWithoutGroupmembersInput
    connect?: usersWhereUniqueInput
  }

  export type groupsCreateNestedOneWithoutGroupmembersInput = {
    create?: XOR<groupsCreateWithoutGroupmembersInput, groupsUncheckedCreateWithoutGroupmembersInput>
    connectOrCreate?: groupsCreateOrConnectWithoutGroupmembersInput
    connect?: groupsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutGroupmembersNestedInput = {
    create?: XOR<usersCreateWithoutGroupmembersInput, usersUncheckedCreateWithoutGroupmembersInput>
    connectOrCreate?: usersCreateOrConnectWithoutGroupmembersInput
    upsert?: usersUpsertWithoutGroupmembersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutGroupmembersInput, usersUpdateWithoutGroupmembersInput>, usersUncheckedUpdateWithoutGroupmembersInput>
  }

  export type groupsUpdateOneRequiredWithoutGroupmembersNestedInput = {
    create?: XOR<groupsCreateWithoutGroupmembersInput, groupsUncheckedCreateWithoutGroupmembersInput>
    connectOrCreate?: groupsCreateOrConnectWithoutGroupmembersInput
    upsert?: groupsUpsertWithoutGroupmembersInput
    connect?: groupsWhereUniqueInput
    update?: XOR<XOR<groupsUpdateToOneWithWhereWithoutGroupmembersInput, groupsUpdateWithoutGroupmembersInput>, groupsUncheckedUpdateWithoutGroupmembersInput>
  }

  export type groupmembersCreateNestedManyWithoutGroupsInput = {
    create?: XOR<groupmembersCreateWithoutGroupsInput, groupmembersUncheckedCreateWithoutGroupsInput> | groupmembersCreateWithoutGroupsInput[] | groupmembersUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: groupmembersCreateOrConnectWithoutGroupsInput | groupmembersCreateOrConnectWithoutGroupsInput[]
    createMany?: groupmembersCreateManyGroupsInputEnvelope
    connect?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutGroupsInput = {
    create?: XOR<usersCreateWithoutGroupsInput, usersUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: usersCreateOrConnectWithoutGroupsInput
    connect?: usersWhereUniqueInput
  }

  export type groupmembersUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<groupmembersCreateWithoutGroupsInput, groupmembersUncheckedCreateWithoutGroupsInput> | groupmembersCreateWithoutGroupsInput[] | groupmembersUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: groupmembersCreateOrConnectWithoutGroupsInput | groupmembersCreateOrConnectWithoutGroupsInput[]
    createMany?: groupmembersCreateManyGroupsInputEnvelope
    connect?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
  }

  export type groupmembersUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<groupmembersCreateWithoutGroupsInput, groupmembersUncheckedCreateWithoutGroupsInput> | groupmembersCreateWithoutGroupsInput[] | groupmembersUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: groupmembersCreateOrConnectWithoutGroupsInput | groupmembersCreateOrConnectWithoutGroupsInput[]
    upsert?: groupmembersUpsertWithWhereUniqueWithoutGroupsInput | groupmembersUpsertWithWhereUniqueWithoutGroupsInput[]
    createMany?: groupmembersCreateManyGroupsInputEnvelope
    set?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    disconnect?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    delete?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    connect?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    update?: groupmembersUpdateWithWhereUniqueWithoutGroupsInput | groupmembersUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: groupmembersUpdateManyWithWhereWithoutGroupsInput | groupmembersUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: groupmembersScalarWhereInput | groupmembersScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutGroupsNestedInput = {
    create?: XOR<usersCreateWithoutGroupsInput, usersUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: usersCreateOrConnectWithoutGroupsInput
    upsert?: usersUpsertWithoutGroupsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutGroupsInput, usersUpdateWithoutGroupsInput>, usersUncheckedUpdateWithoutGroupsInput>
  }

  export type groupmembersUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<groupmembersCreateWithoutGroupsInput, groupmembersUncheckedCreateWithoutGroupsInput> | groupmembersCreateWithoutGroupsInput[] | groupmembersUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: groupmembersCreateOrConnectWithoutGroupsInput | groupmembersCreateOrConnectWithoutGroupsInput[]
    upsert?: groupmembersUpsertWithWhereUniqueWithoutGroupsInput | groupmembersUpsertWithWhereUniqueWithoutGroupsInput[]
    createMany?: groupmembersCreateManyGroupsInputEnvelope
    set?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    disconnect?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    delete?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    connect?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    update?: groupmembersUpdateWithWhereUniqueWithoutGroupsInput | groupmembersUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: groupmembersUpdateManyWithWhereWithoutGroupsInput | groupmembersUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: groupmembersScalarWhereInput | groupmembersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutLikesInput = {
    create?: XOR<usersCreateWithoutLikesInput, usersUncheckedCreateWithoutLikesInput>
    connectOrCreate?: usersCreateOrConnectWithoutLikesInput
    connect?: usersWhereUniqueInput
  }

  export type listsCreateNestedOneWithoutLikesInput = {
    create?: XOR<listsCreateWithoutLikesInput, listsUncheckedCreateWithoutLikesInput>
    connectOrCreate?: listsCreateOrConnectWithoutLikesInput
    connect?: listsWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<usersCreateWithoutLikesInput, usersUncheckedCreateWithoutLikesInput>
    connectOrCreate?: usersCreateOrConnectWithoutLikesInput
    upsert?: usersUpsertWithoutLikesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutLikesInput, usersUpdateWithoutLikesInput>, usersUncheckedUpdateWithoutLikesInput>
  }

  export type listsUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<listsCreateWithoutLikesInput, listsUncheckedCreateWithoutLikesInput>
    connectOrCreate?: listsCreateOrConnectWithoutLikesInput
    upsert?: listsUpsertWithoutLikesInput
    connect?: listsWhereUniqueInput
    update?: XOR<XOR<listsUpdateToOneWithWhereWithoutLikesInput, listsUpdateWithoutLikesInput>, listsUncheckedUpdateWithoutLikesInput>
  }

  export type listsCreateNestedOneWithoutListitemsInput = {
    create?: XOR<listsCreateWithoutListitemsInput, listsUncheckedCreateWithoutListitemsInput>
    connectOrCreate?: listsCreateOrConnectWithoutListitemsInput
    connect?: listsWhereUniqueInput
  }

  export type listsUpdateOneRequiredWithoutListitemsNestedInput = {
    create?: XOR<listsCreateWithoutListitemsInput, listsUncheckedCreateWithoutListitemsInput>
    connectOrCreate?: listsCreateOrConnectWithoutListitemsInput
    upsert?: listsUpsertWithoutListitemsInput
    connect?: listsWhereUniqueInput
    update?: XOR<XOR<listsUpdateToOneWithWhereWithoutListitemsInput, listsUpdateWithoutListitemsInput>, listsUncheckedUpdateWithoutListitemsInput>
  }

  export type likesCreateNestedManyWithoutListitemsInput = {
    create?: XOR<likesCreateWithoutListitemsInput, likesUncheckedCreateWithoutListitemsInput> | likesCreateWithoutListitemsInput[] | likesUncheckedCreateWithoutListitemsInput[]
    connectOrCreate?: likesCreateOrConnectWithoutListitemsInput | likesCreateOrConnectWithoutListitemsInput[]
    createMany?: likesCreateManyListitemsInputEnvelope
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
  }

  export type listitemsCreateNestedManyWithoutListsInput = {
    create?: XOR<listitemsCreateWithoutListsInput, listitemsUncheckedCreateWithoutListsInput> | listitemsCreateWithoutListsInput[] | listitemsUncheckedCreateWithoutListsInput[]
    connectOrCreate?: listitemsCreateOrConnectWithoutListsInput | listitemsCreateOrConnectWithoutListsInput[]
    createMany?: listitemsCreateManyListsInputEnvelope
    connect?: listitemsWhereUniqueInput | listitemsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutListsInput = {
    create?: XOR<usersCreateWithoutListsInput, usersUncheckedCreateWithoutListsInput>
    connectOrCreate?: usersCreateOrConnectWithoutListsInput
    connect?: usersWhereUniqueInput
  }

  export type likesUncheckedCreateNestedManyWithoutListitemsInput = {
    create?: XOR<likesCreateWithoutListitemsInput, likesUncheckedCreateWithoutListitemsInput> | likesCreateWithoutListitemsInput[] | likesUncheckedCreateWithoutListitemsInput[]
    connectOrCreate?: likesCreateOrConnectWithoutListitemsInput | likesCreateOrConnectWithoutListitemsInput[]
    createMany?: likesCreateManyListitemsInputEnvelope
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
  }

  export type listitemsUncheckedCreateNestedManyWithoutListsInput = {
    create?: XOR<listitemsCreateWithoutListsInput, listitemsUncheckedCreateWithoutListsInput> | listitemsCreateWithoutListsInput[] | listitemsUncheckedCreateWithoutListsInput[]
    connectOrCreate?: listitemsCreateOrConnectWithoutListsInput | listitemsCreateOrConnectWithoutListsInput[]
    createMany?: listitemsCreateManyListsInputEnvelope
    connect?: listitemsWhereUniqueInput | listitemsWhereUniqueInput[]
  }

  export type EnumlisttypeFieldUpdateOperationsInput = {
    set?: $Enums.listtype
  }

  export type likesUpdateManyWithoutListitemsNestedInput = {
    create?: XOR<likesCreateWithoutListitemsInput, likesUncheckedCreateWithoutListitemsInput> | likesCreateWithoutListitemsInput[] | likesUncheckedCreateWithoutListitemsInput[]
    connectOrCreate?: likesCreateOrConnectWithoutListitemsInput | likesCreateOrConnectWithoutListitemsInput[]
    upsert?: likesUpsertWithWhereUniqueWithoutListitemsInput | likesUpsertWithWhereUniqueWithoutListitemsInput[]
    createMany?: likesCreateManyListitemsInputEnvelope
    set?: likesWhereUniqueInput | likesWhereUniqueInput[]
    disconnect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    delete?: likesWhereUniqueInput | likesWhereUniqueInput[]
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    update?: likesUpdateWithWhereUniqueWithoutListitemsInput | likesUpdateWithWhereUniqueWithoutListitemsInput[]
    updateMany?: likesUpdateManyWithWhereWithoutListitemsInput | likesUpdateManyWithWhereWithoutListitemsInput[]
    deleteMany?: likesScalarWhereInput | likesScalarWhereInput[]
  }

  export type listitemsUpdateManyWithoutListsNestedInput = {
    create?: XOR<listitemsCreateWithoutListsInput, listitemsUncheckedCreateWithoutListsInput> | listitemsCreateWithoutListsInput[] | listitemsUncheckedCreateWithoutListsInput[]
    connectOrCreate?: listitemsCreateOrConnectWithoutListsInput | listitemsCreateOrConnectWithoutListsInput[]
    upsert?: listitemsUpsertWithWhereUniqueWithoutListsInput | listitemsUpsertWithWhereUniqueWithoutListsInput[]
    createMany?: listitemsCreateManyListsInputEnvelope
    set?: listitemsWhereUniqueInput | listitemsWhereUniqueInput[]
    disconnect?: listitemsWhereUniqueInput | listitemsWhereUniqueInput[]
    delete?: listitemsWhereUniqueInput | listitemsWhereUniqueInput[]
    connect?: listitemsWhereUniqueInput | listitemsWhereUniqueInput[]
    update?: listitemsUpdateWithWhereUniqueWithoutListsInput | listitemsUpdateWithWhereUniqueWithoutListsInput[]
    updateMany?: listitemsUpdateManyWithWhereWithoutListsInput | listitemsUpdateManyWithWhereWithoutListsInput[]
    deleteMany?: listitemsScalarWhereInput | listitemsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutListsNestedInput = {
    create?: XOR<usersCreateWithoutListsInput, usersUncheckedCreateWithoutListsInput>
    connectOrCreate?: usersCreateOrConnectWithoutListsInput
    upsert?: usersUpsertWithoutListsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutListsInput, usersUpdateWithoutListsInput>, usersUncheckedUpdateWithoutListsInput>
  }

  export type likesUncheckedUpdateManyWithoutListitemsNestedInput = {
    create?: XOR<likesCreateWithoutListitemsInput, likesUncheckedCreateWithoutListitemsInput> | likesCreateWithoutListitemsInput[] | likesUncheckedCreateWithoutListitemsInput[]
    connectOrCreate?: likesCreateOrConnectWithoutListitemsInput | likesCreateOrConnectWithoutListitemsInput[]
    upsert?: likesUpsertWithWhereUniqueWithoutListitemsInput | likesUpsertWithWhereUniqueWithoutListitemsInput[]
    createMany?: likesCreateManyListitemsInputEnvelope
    set?: likesWhereUniqueInput | likesWhereUniqueInput[]
    disconnect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    delete?: likesWhereUniqueInput | likesWhereUniqueInput[]
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    update?: likesUpdateWithWhereUniqueWithoutListitemsInput | likesUpdateWithWhereUniqueWithoutListitemsInput[]
    updateMany?: likesUpdateManyWithWhereWithoutListitemsInput | likesUpdateManyWithWhereWithoutListitemsInput[]
    deleteMany?: likesScalarWhereInput | likesScalarWhereInput[]
  }

  export type listitemsUncheckedUpdateManyWithoutListsNestedInput = {
    create?: XOR<listitemsCreateWithoutListsInput, listitemsUncheckedCreateWithoutListsInput> | listitemsCreateWithoutListsInput[] | listitemsUncheckedCreateWithoutListsInput[]
    connectOrCreate?: listitemsCreateOrConnectWithoutListsInput | listitemsCreateOrConnectWithoutListsInput[]
    upsert?: listitemsUpsertWithWhereUniqueWithoutListsInput | listitemsUpsertWithWhereUniqueWithoutListsInput[]
    createMany?: listitemsCreateManyListsInputEnvelope
    set?: listitemsWhereUniqueInput | listitemsWhereUniqueInput[]
    disconnect?: listitemsWhereUniqueInput | listitemsWhereUniqueInput[]
    delete?: listitemsWhereUniqueInput | listitemsWhereUniqueInput[]
    connect?: listitemsWhereUniqueInput | listitemsWhereUniqueInput[]
    update?: listitemsUpdateWithWhereUniqueWithoutListsInput | listitemsUpdateWithWhereUniqueWithoutListsInput[]
    updateMany?: listitemsUpdateManyWithWhereWithoutListsInput | listitemsUpdateManyWithWhereWithoutListsInput[]
    deleteMany?: listitemsScalarWhereInput | listitemsScalarWhereInput[]
  }

  export type followsCreateNestedManyWithoutUsers_follows_followeremailTousersInput = {
    create?: XOR<followsCreateWithoutUsers_follows_followeremailTousersInput, followsUncheckedCreateWithoutUsers_follows_followeremailTousersInput> | followsCreateWithoutUsers_follows_followeremailTousersInput[] | followsUncheckedCreateWithoutUsers_follows_followeremailTousersInput[]
    connectOrCreate?: followsCreateOrConnectWithoutUsers_follows_followeremailTousersInput | followsCreateOrConnectWithoutUsers_follows_followeremailTousersInput[]
    createMany?: followsCreateManyUsers_follows_followeremailTousersInputEnvelope
    connect?: followsWhereUniqueInput | followsWhereUniqueInput[]
  }

  export type followsCreateNestedManyWithoutUsers_follows_followingemailTousersInput = {
    create?: XOR<followsCreateWithoutUsers_follows_followingemailTousersInput, followsUncheckedCreateWithoutUsers_follows_followingemailTousersInput> | followsCreateWithoutUsers_follows_followingemailTousersInput[] | followsUncheckedCreateWithoutUsers_follows_followingemailTousersInput[]
    connectOrCreate?: followsCreateOrConnectWithoutUsers_follows_followingemailTousersInput | followsCreateOrConnectWithoutUsers_follows_followingemailTousersInput[]
    createMany?: followsCreateManyUsers_follows_followingemailTousersInputEnvelope
    connect?: followsWhereUniqueInput | followsWhereUniqueInput[]
  }

  export type groupmembersCreateNestedManyWithoutUsersInput = {
    create?: XOR<groupmembersCreateWithoutUsersInput, groupmembersUncheckedCreateWithoutUsersInput> | groupmembersCreateWithoutUsersInput[] | groupmembersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: groupmembersCreateOrConnectWithoutUsersInput | groupmembersCreateOrConnectWithoutUsersInput[]
    createMany?: groupmembersCreateManyUsersInputEnvelope
    connect?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
  }

  export type groupsCreateNestedManyWithoutUsersInput = {
    create?: XOR<groupsCreateWithoutUsersInput, groupsUncheckedCreateWithoutUsersInput> | groupsCreateWithoutUsersInput[] | groupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: groupsCreateOrConnectWithoutUsersInput | groupsCreateOrConnectWithoutUsersInput[]
    createMany?: groupsCreateManyUsersInputEnvelope
    connect?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
  }

  export type likesCreateNestedManyWithoutUsersInput = {
    create?: XOR<likesCreateWithoutUsersInput, likesUncheckedCreateWithoutUsersInput> | likesCreateWithoutUsersInput[] | likesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: likesCreateOrConnectWithoutUsersInput | likesCreateOrConnectWithoutUsersInput[]
    createMany?: likesCreateManyUsersInputEnvelope
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
  }

  export type listsCreateNestedManyWithoutUsersInput = {
    create?: XOR<listsCreateWithoutUsersInput, listsUncheckedCreateWithoutUsersInput> | listsCreateWithoutUsersInput[] | listsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: listsCreateOrConnectWithoutUsersInput | listsCreateOrConnectWithoutUsersInput[]
    createMany?: listsCreateManyUsersInputEnvelope
    connect?: listsWhereUniqueInput | listsWhereUniqueInput[]
  }

  export type followsUncheckedCreateNestedManyWithoutUsers_follows_followeremailTousersInput = {
    create?: XOR<followsCreateWithoutUsers_follows_followeremailTousersInput, followsUncheckedCreateWithoutUsers_follows_followeremailTousersInput> | followsCreateWithoutUsers_follows_followeremailTousersInput[] | followsUncheckedCreateWithoutUsers_follows_followeremailTousersInput[]
    connectOrCreate?: followsCreateOrConnectWithoutUsers_follows_followeremailTousersInput | followsCreateOrConnectWithoutUsers_follows_followeremailTousersInput[]
    createMany?: followsCreateManyUsers_follows_followeremailTousersInputEnvelope
    connect?: followsWhereUniqueInput | followsWhereUniqueInput[]
  }

  export type followsUncheckedCreateNestedManyWithoutUsers_follows_followingemailTousersInput = {
    create?: XOR<followsCreateWithoutUsers_follows_followingemailTousersInput, followsUncheckedCreateWithoutUsers_follows_followingemailTousersInput> | followsCreateWithoutUsers_follows_followingemailTousersInput[] | followsUncheckedCreateWithoutUsers_follows_followingemailTousersInput[]
    connectOrCreate?: followsCreateOrConnectWithoutUsers_follows_followingemailTousersInput | followsCreateOrConnectWithoutUsers_follows_followingemailTousersInput[]
    createMany?: followsCreateManyUsers_follows_followingemailTousersInputEnvelope
    connect?: followsWhereUniqueInput | followsWhereUniqueInput[]
  }

  export type groupmembersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<groupmembersCreateWithoutUsersInput, groupmembersUncheckedCreateWithoutUsersInput> | groupmembersCreateWithoutUsersInput[] | groupmembersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: groupmembersCreateOrConnectWithoutUsersInput | groupmembersCreateOrConnectWithoutUsersInput[]
    createMany?: groupmembersCreateManyUsersInputEnvelope
    connect?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
  }

  export type groupsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<groupsCreateWithoutUsersInput, groupsUncheckedCreateWithoutUsersInput> | groupsCreateWithoutUsersInput[] | groupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: groupsCreateOrConnectWithoutUsersInput | groupsCreateOrConnectWithoutUsersInput[]
    createMany?: groupsCreateManyUsersInputEnvelope
    connect?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
  }

  export type likesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<likesCreateWithoutUsersInput, likesUncheckedCreateWithoutUsersInput> | likesCreateWithoutUsersInput[] | likesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: likesCreateOrConnectWithoutUsersInput | likesCreateOrConnectWithoutUsersInput[]
    createMany?: likesCreateManyUsersInputEnvelope
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
  }

  export type listsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<listsCreateWithoutUsersInput, listsUncheckedCreateWithoutUsersInput> | listsCreateWithoutUsersInput[] | listsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: listsCreateOrConnectWithoutUsersInput | listsCreateOrConnectWithoutUsersInput[]
    createMany?: listsCreateManyUsersInputEnvelope
    connect?: listsWhereUniqueInput | listsWhereUniqueInput[]
  }

  export type followsUpdateManyWithoutUsers_follows_followeremailTousersNestedInput = {
    create?: XOR<followsCreateWithoutUsers_follows_followeremailTousersInput, followsUncheckedCreateWithoutUsers_follows_followeremailTousersInput> | followsCreateWithoutUsers_follows_followeremailTousersInput[] | followsUncheckedCreateWithoutUsers_follows_followeremailTousersInput[]
    connectOrCreate?: followsCreateOrConnectWithoutUsers_follows_followeremailTousersInput | followsCreateOrConnectWithoutUsers_follows_followeremailTousersInput[]
    upsert?: followsUpsertWithWhereUniqueWithoutUsers_follows_followeremailTousersInput | followsUpsertWithWhereUniqueWithoutUsers_follows_followeremailTousersInput[]
    createMany?: followsCreateManyUsers_follows_followeremailTousersInputEnvelope
    set?: followsWhereUniqueInput | followsWhereUniqueInput[]
    disconnect?: followsWhereUniqueInput | followsWhereUniqueInput[]
    delete?: followsWhereUniqueInput | followsWhereUniqueInput[]
    connect?: followsWhereUniqueInput | followsWhereUniqueInput[]
    update?: followsUpdateWithWhereUniqueWithoutUsers_follows_followeremailTousersInput | followsUpdateWithWhereUniqueWithoutUsers_follows_followeremailTousersInput[]
    updateMany?: followsUpdateManyWithWhereWithoutUsers_follows_followeremailTousersInput | followsUpdateManyWithWhereWithoutUsers_follows_followeremailTousersInput[]
    deleteMany?: followsScalarWhereInput | followsScalarWhereInput[]
  }

  export type followsUpdateManyWithoutUsers_follows_followingemailTousersNestedInput = {
    create?: XOR<followsCreateWithoutUsers_follows_followingemailTousersInput, followsUncheckedCreateWithoutUsers_follows_followingemailTousersInput> | followsCreateWithoutUsers_follows_followingemailTousersInput[] | followsUncheckedCreateWithoutUsers_follows_followingemailTousersInput[]
    connectOrCreate?: followsCreateOrConnectWithoutUsers_follows_followingemailTousersInput | followsCreateOrConnectWithoutUsers_follows_followingemailTousersInput[]
    upsert?: followsUpsertWithWhereUniqueWithoutUsers_follows_followingemailTousersInput | followsUpsertWithWhereUniqueWithoutUsers_follows_followingemailTousersInput[]
    createMany?: followsCreateManyUsers_follows_followingemailTousersInputEnvelope
    set?: followsWhereUniqueInput | followsWhereUniqueInput[]
    disconnect?: followsWhereUniqueInput | followsWhereUniqueInput[]
    delete?: followsWhereUniqueInput | followsWhereUniqueInput[]
    connect?: followsWhereUniqueInput | followsWhereUniqueInput[]
    update?: followsUpdateWithWhereUniqueWithoutUsers_follows_followingemailTousersInput | followsUpdateWithWhereUniqueWithoutUsers_follows_followingemailTousersInput[]
    updateMany?: followsUpdateManyWithWhereWithoutUsers_follows_followingemailTousersInput | followsUpdateManyWithWhereWithoutUsers_follows_followingemailTousersInput[]
    deleteMany?: followsScalarWhereInput | followsScalarWhereInput[]
  }

  export type groupmembersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<groupmembersCreateWithoutUsersInput, groupmembersUncheckedCreateWithoutUsersInput> | groupmembersCreateWithoutUsersInput[] | groupmembersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: groupmembersCreateOrConnectWithoutUsersInput | groupmembersCreateOrConnectWithoutUsersInput[]
    upsert?: groupmembersUpsertWithWhereUniqueWithoutUsersInput | groupmembersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: groupmembersCreateManyUsersInputEnvelope
    set?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    disconnect?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    delete?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    connect?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    update?: groupmembersUpdateWithWhereUniqueWithoutUsersInput | groupmembersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: groupmembersUpdateManyWithWhereWithoutUsersInput | groupmembersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: groupmembersScalarWhereInput | groupmembersScalarWhereInput[]
  }

  export type groupsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<groupsCreateWithoutUsersInput, groupsUncheckedCreateWithoutUsersInput> | groupsCreateWithoutUsersInput[] | groupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: groupsCreateOrConnectWithoutUsersInput | groupsCreateOrConnectWithoutUsersInput[]
    upsert?: groupsUpsertWithWhereUniqueWithoutUsersInput | groupsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: groupsCreateManyUsersInputEnvelope
    set?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    disconnect?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    delete?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    connect?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    update?: groupsUpdateWithWhereUniqueWithoutUsersInput | groupsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: groupsUpdateManyWithWhereWithoutUsersInput | groupsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: groupsScalarWhereInput | groupsScalarWhereInput[]
  }

  export type likesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<likesCreateWithoutUsersInput, likesUncheckedCreateWithoutUsersInput> | likesCreateWithoutUsersInput[] | likesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: likesCreateOrConnectWithoutUsersInput | likesCreateOrConnectWithoutUsersInput[]
    upsert?: likesUpsertWithWhereUniqueWithoutUsersInput | likesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: likesCreateManyUsersInputEnvelope
    set?: likesWhereUniqueInput | likesWhereUniqueInput[]
    disconnect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    delete?: likesWhereUniqueInput | likesWhereUniqueInput[]
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    update?: likesUpdateWithWhereUniqueWithoutUsersInput | likesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: likesUpdateManyWithWhereWithoutUsersInput | likesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: likesScalarWhereInput | likesScalarWhereInput[]
  }

  export type listsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<listsCreateWithoutUsersInput, listsUncheckedCreateWithoutUsersInput> | listsCreateWithoutUsersInput[] | listsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: listsCreateOrConnectWithoutUsersInput | listsCreateOrConnectWithoutUsersInput[]
    upsert?: listsUpsertWithWhereUniqueWithoutUsersInput | listsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: listsCreateManyUsersInputEnvelope
    set?: listsWhereUniqueInput | listsWhereUniqueInput[]
    disconnect?: listsWhereUniqueInput | listsWhereUniqueInput[]
    delete?: listsWhereUniqueInput | listsWhereUniqueInput[]
    connect?: listsWhereUniqueInput | listsWhereUniqueInput[]
    update?: listsUpdateWithWhereUniqueWithoutUsersInput | listsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: listsUpdateManyWithWhereWithoutUsersInput | listsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: listsScalarWhereInput | listsScalarWhereInput[]
  }

  export type followsUncheckedUpdateManyWithoutUsers_follows_followeremailTousersNestedInput = {
    create?: XOR<followsCreateWithoutUsers_follows_followeremailTousersInput, followsUncheckedCreateWithoutUsers_follows_followeremailTousersInput> | followsCreateWithoutUsers_follows_followeremailTousersInput[] | followsUncheckedCreateWithoutUsers_follows_followeremailTousersInput[]
    connectOrCreate?: followsCreateOrConnectWithoutUsers_follows_followeremailTousersInput | followsCreateOrConnectWithoutUsers_follows_followeremailTousersInput[]
    upsert?: followsUpsertWithWhereUniqueWithoutUsers_follows_followeremailTousersInput | followsUpsertWithWhereUniqueWithoutUsers_follows_followeremailTousersInput[]
    createMany?: followsCreateManyUsers_follows_followeremailTousersInputEnvelope
    set?: followsWhereUniqueInput | followsWhereUniqueInput[]
    disconnect?: followsWhereUniqueInput | followsWhereUniqueInput[]
    delete?: followsWhereUniqueInput | followsWhereUniqueInput[]
    connect?: followsWhereUniqueInput | followsWhereUniqueInput[]
    update?: followsUpdateWithWhereUniqueWithoutUsers_follows_followeremailTousersInput | followsUpdateWithWhereUniqueWithoutUsers_follows_followeremailTousersInput[]
    updateMany?: followsUpdateManyWithWhereWithoutUsers_follows_followeremailTousersInput | followsUpdateManyWithWhereWithoutUsers_follows_followeremailTousersInput[]
    deleteMany?: followsScalarWhereInput | followsScalarWhereInput[]
  }

  export type followsUncheckedUpdateManyWithoutUsers_follows_followingemailTousersNestedInput = {
    create?: XOR<followsCreateWithoutUsers_follows_followingemailTousersInput, followsUncheckedCreateWithoutUsers_follows_followingemailTousersInput> | followsCreateWithoutUsers_follows_followingemailTousersInput[] | followsUncheckedCreateWithoutUsers_follows_followingemailTousersInput[]
    connectOrCreate?: followsCreateOrConnectWithoutUsers_follows_followingemailTousersInput | followsCreateOrConnectWithoutUsers_follows_followingemailTousersInput[]
    upsert?: followsUpsertWithWhereUniqueWithoutUsers_follows_followingemailTousersInput | followsUpsertWithWhereUniqueWithoutUsers_follows_followingemailTousersInput[]
    createMany?: followsCreateManyUsers_follows_followingemailTousersInputEnvelope
    set?: followsWhereUniqueInput | followsWhereUniqueInput[]
    disconnect?: followsWhereUniqueInput | followsWhereUniqueInput[]
    delete?: followsWhereUniqueInput | followsWhereUniqueInput[]
    connect?: followsWhereUniqueInput | followsWhereUniqueInput[]
    update?: followsUpdateWithWhereUniqueWithoutUsers_follows_followingemailTousersInput | followsUpdateWithWhereUniqueWithoutUsers_follows_followingemailTousersInput[]
    updateMany?: followsUpdateManyWithWhereWithoutUsers_follows_followingemailTousersInput | followsUpdateManyWithWhereWithoutUsers_follows_followingemailTousersInput[]
    deleteMany?: followsScalarWhereInput | followsScalarWhereInput[]
  }

  export type groupmembersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<groupmembersCreateWithoutUsersInput, groupmembersUncheckedCreateWithoutUsersInput> | groupmembersCreateWithoutUsersInput[] | groupmembersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: groupmembersCreateOrConnectWithoutUsersInput | groupmembersCreateOrConnectWithoutUsersInput[]
    upsert?: groupmembersUpsertWithWhereUniqueWithoutUsersInput | groupmembersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: groupmembersCreateManyUsersInputEnvelope
    set?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    disconnect?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    delete?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    connect?: groupmembersWhereUniqueInput | groupmembersWhereUniqueInput[]
    update?: groupmembersUpdateWithWhereUniqueWithoutUsersInput | groupmembersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: groupmembersUpdateManyWithWhereWithoutUsersInput | groupmembersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: groupmembersScalarWhereInput | groupmembersScalarWhereInput[]
  }

  export type groupsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<groupsCreateWithoutUsersInput, groupsUncheckedCreateWithoutUsersInput> | groupsCreateWithoutUsersInput[] | groupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: groupsCreateOrConnectWithoutUsersInput | groupsCreateOrConnectWithoutUsersInput[]
    upsert?: groupsUpsertWithWhereUniqueWithoutUsersInput | groupsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: groupsCreateManyUsersInputEnvelope
    set?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    disconnect?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    delete?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    connect?: groupsWhereUniqueInput | groupsWhereUniqueInput[]
    update?: groupsUpdateWithWhereUniqueWithoutUsersInput | groupsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: groupsUpdateManyWithWhereWithoutUsersInput | groupsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: groupsScalarWhereInput | groupsScalarWhereInput[]
  }

  export type likesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<likesCreateWithoutUsersInput, likesUncheckedCreateWithoutUsersInput> | likesCreateWithoutUsersInput[] | likesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: likesCreateOrConnectWithoutUsersInput | likesCreateOrConnectWithoutUsersInput[]
    upsert?: likesUpsertWithWhereUniqueWithoutUsersInput | likesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: likesCreateManyUsersInputEnvelope
    set?: likesWhereUniqueInput | likesWhereUniqueInput[]
    disconnect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    delete?: likesWhereUniqueInput | likesWhereUniqueInput[]
    connect?: likesWhereUniqueInput | likesWhereUniqueInput[]
    update?: likesUpdateWithWhereUniqueWithoutUsersInput | likesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: likesUpdateManyWithWhereWithoutUsersInput | likesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: likesScalarWhereInput | likesScalarWhereInput[]
  }

  export type listsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<listsCreateWithoutUsersInput, listsUncheckedCreateWithoutUsersInput> | listsCreateWithoutUsersInput[] | listsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: listsCreateOrConnectWithoutUsersInput | listsCreateOrConnectWithoutUsersInput[]
    upsert?: listsUpsertWithWhereUniqueWithoutUsersInput | listsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: listsCreateManyUsersInputEnvelope
    set?: listsWhereUniqueInput | listsWhereUniqueInput[]
    disconnect?: listsWhereUniqueInput | listsWhereUniqueInput[]
    delete?: listsWhereUniqueInput | listsWhereUniqueInput[]
    connect?: listsWhereUniqueInput | listsWhereUniqueInput[]
    update?: listsUpdateWithWhereUniqueWithoutUsersInput | listsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: listsUpdateManyWithWhereWithoutUsersInput | listsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: listsScalarWhereInput | listsScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumlisttypeFilter<$PrismaModel = never> = {
    equals?: $Enums.listtype | EnumlisttypeFieldRefInput<$PrismaModel>
    in?: $Enums.listtype[] | ListEnumlisttypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.listtype[] | ListEnumlisttypeFieldRefInput<$PrismaModel>
    not?: NestedEnumlisttypeFilter<$PrismaModel> | $Enums.listtype
  }

  export type NestedEnumlisttypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.listtype | EnumlisttypeFieldRefInput<$PrismaModel>
    in?: $Enums.listtype[] | ListEnumlisttypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.listtype[] | ListEnumlisttypeFieldRefInput<$PrismaModel>
    not?: NestedEnumlisttypeWithAggregatesFilter<$PrismaModel> | $Enums.listtype
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumlisttypeFilter<$PrismaModel>
    _max?: NestedEnumlisttypeFilter<$PrismaModel>
  }

  export type usersCreateWithoutFollows_follows_followeremailTousersInput = {
    email: string
    displayname: string
    userpassword: string
    createdat?: Date | string | null
    follows_follows_followingemailTousers?: followsCreateNestedManyWithoutUsers_follows_followingemailTousersInput
    groupmembers?: groupmembersCreateNestedManyWithoutUsersInput
    groups?: groupsCreateNestedManyWithoutUsersInput
    likes?: likesCreateNestedManyWithoutUsersInput
    lists?: listsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutFollows_follows_followeremailTousersInput = {
    email: string
    displayname: string
    userpassword: string
    createdat?: Date | string | null
    follows_follows_followingemailTousers?: followsUncheckedCreateNestedManyWithoutUsers_follows_followingemailTousersInput
    groupmembers?: groupmembersUncheckedCreateNestedManyWithoutUsersInput
    groups?: groupsUncheckedCreateNestedManyWithoutUsersInput
    likes?: likesUncheckedCreateNestedManyWithoutUsersInput
    lists?: listsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutFollows_follows_followeremailTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFollows_follows_followeremailTousersInput, usersUncheckedCreateWithoutFollows_follows_followeremailTousersInput>
  }

  export type usersCreateWithoutFollows_follows_followingemailTousersInput = {
    email: string
    displayname: string
    userpassword: string
    createdat?: Date | string | null
    follows_follows_followeremailTousers?: followsCreateNestedManyWithoutUsers_follows_followeremailTousersInput
    groupmembers?: groupmembersCreateNestedManyWithoutUsersInput
    groups?: groupsCreateNestedManyWithoutUsersInput
    likes?: likesCreateNestedManyWithoutUsersInput
    lists?: listsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutFollows_follows_followingemailTousersInput = {
    email: string
    displayname: string
    userpassword: string
    createdat?: Date | string | null
    follows_follows_followeremailTousers?: followsUncheckedCreateNestedManyWithoutUsers_follows_followeremailTousersInput
    groupmembers?: groupmembersUncheckedCreateNestedManyWithoutUsersInput
    groups?: groupsUncheckedCreateNestedManyWithoutUsersInput
    likes?: likesUncheckedCreateNestedManyWithoutUsersInput
    lists?: listsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutFollows_follows_followingemailTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFollows_follows_followingemailTousersInput, usersUncheckedCreateWithoutFollows_follows_followingemailTousersInput>
  }

  export type usersUpsertWithoutFollows_follows_followeremailTousersInput = {
    update: XOR<usersUpdateWithoutFollows_follows_followeremailTousersInput, usersUncheckedUpdateWithoutFollows_follows_followeremailTousersInput>
    create: XOR<usersCreateWithoutFollows_follows_followeremailTousersInput, usersUncheckedCreateWithoutFollows_follows_followeremailTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFollows_follows_followeremailTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFollows_follows_followeremailTousersInput, usersUncheckedUpdateWithoutFollows_follows_followeremailTousersInput>
  }

  export type usersUpdateWithoutFollows_follows_followeremailTousersInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follows_follows_followingemailTousers?: followsUpdateManyWithoutUsers_follows_followingemailTousersNestedInput
    groupmembers?: groupmembersUpdateManyWithoutUsersNestedInput
    groups?: groupsUpdateManyWithoutUsersNestedInput
    likes?: likesUpdateManyWithoutUsersNestedInput
    lists?: listsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutFollows_follows_followeremailTousersInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follows_follows_followingemailTousers?: followsUncheckedUpdateManyWithoutUsers_follows_followingemailTousersNestedInput
    groupmembers?: groupmembersUncheckedUpdateManyWithoutUsersNestedInput
    groups?: groupsUncheckedUpdateManyWithoutUsersNestedInput
    likes?: likesUncheckedUpdateManyWithoutUsersNestedInput
    lists?: listsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUpsertWithoutFollows_follows_followingemailTousersInput = {
    update: XOR<usersUpdateWithoutFollows_follows_followingemailTousersInput, usersUncheckedUpdateWithoutFollows_follows_followingemailTousersInput>
    create: XOR<usersCreateWithoutFollows_follows_followingemailTousersInput, usersUncheckedCreateWithoutFollows_follows_followingemailTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFollows_follows_followingemailTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFollows_follows_followingemailTousersInput, usersUncheckedUpdateWithoutFollows_follows_followingemailTousersInput>
  }

  export type usersUpdateWithoutFollows_follows_followingemailTousersInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follows_follows_followeremailTousers?: followsUpdateManyWithoutUsers_follows_followeremailTousersNestedInput
    groupmembers?: groupmembersUpdateManyWithoutUsersNestedInput
    groups?: groupsUpdateManyWithoutUsersNestedInput
    likes?: likesUpdateManyWithoutUsersNestedInput
    lists?: listsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutFollows_follows_followingemailTousersInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follows_follows_followeremailTousers?: followsUncheckedUpdateManyWithoutUsers_follows_followeremailTousersNestedInput
    groupmembers?: groupmembersUncheckedUpdateManyWithoutUsersNestedInput
    groups?: groupsUncheckedUpdateManyWithoutUsersNestedInput
    likes?: likesUncheckedUpdateManyWithoutUsersNestedInput
    lists?: listsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutGroupmembersInput = {
    email: string
    displayname: string
    userpassword: string
    createdat?: Date | string | null
    follows_follows_followeremailTousers?: followsCreateNestedManyWithoutUsers_follows_followeremailTousersInput
    follows_follows_followingemailTousers?: followsCreateNestedManyWithoutUsers_follows_followingemailTousersInput
    groups?: groupsCreateNestedManyWithoutUsersInput
    likes?: likesCreateNestedManyWithoutUsersInput
    lists?: listsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutGroupmembersInput = {
    email: string
    displayname: string
    userpassword: string
    createdat?: Date | string | null
    follows_follows_followeremailTousers?: followsUncheckedCreateNestedManyWithoutUsers_follows_followeremailTousersInput
    follows_follows_followingemailTousers?: followsUncheckedCreateNestedManyWithoutUsers_follows_followingemailTousersInput
    groups?: groupsUncheckedCreateNestedManyWithoutUsersInput
    likes?: likesUncheckedCreateNestedManyWithoutUsersInput
    lists?: listsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutGroupmembersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutGroupmembersInput, usersUncheckedCreateWithoutGroupmembersInput>
  }

  export type groupsCreateWithoutGroupmembersInput = {
    groupname: string
    users: usersCreateNestedOneWithoutGroupsInput
  }

  export type groupsUncheckedCreateWithoutGroupmembersInput = {
    gid?: number
    groupname: string
    ownedby: string
  }

  export type groupsCreateOrConnectWithoutGroupmembersInput = {
    where: groupsWhereUniqueInput
    create: XOR<groupsCreateWithoutGroupmembersInput, groupsUncheckedCreateWithoutGroupmembersInput>
  }

  export type usersUpsertWithoutGroupmembersInput = {
    update: XOR<usersUpdateWithoutGroupmembersInput, usersUncheckedUpdateWithoutGroupmembersInput>
    create: XOR<usersCreateWithoutGroupmembersInput, usersUncheckedCreateWithoutGroupmembersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutGroupmembersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutGroupmembersInput, usersUncheckedUpdateWithoutGroupmembersInput>
  }

  export type usersUpdateWithoutGroupmembersInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follows_follows_followeremailTousers?: followsUpdateManyWithoutUsers_follows_followeremailTousersNestedInput
    follows_follows_followingemailTousers?: followsUpdateManyWithoutUsers_follows_followingemailTousersNestedInput
    groups?: groupsUpdateManyWithoutUsersNestedInput
    likes?: likesUpdateManyWithoutUsersNestedInput
    lists?: listsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutGroupmembersInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follows_follows_followeremailTousers?: followsUncheckedUpdateManyWithoutUsers_follows_followeremailTousersNestedInput
    follows_follows_followingemailTousers?: followsUncheckedUpdateManyWithoutUsers_follows_followingemailTousersNestedInput
    groups?: groupsUncheckedUpdateManyWithoutUsersNestedInput
    likes?: likesUncheckedUpdateManyWithoutUsersNestedInput
    lists?: listsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type groupsUpsertWithoutGroupmembersInput = {
    update: XOR<groupsUpdateWithoutGroupmembersInput, groupsUncheckedUpdateWithoutGroupmembersInput>
    create: XOR<groupsCreateWithoutGroupmembersInput, groupsUncheckedCreateWithoutGroupmembersInput>
    where?: groupsWhereInput
  }

  export type groupsUpdateToOneWithWhereWithoutGroupmembersInput = {
    where?: groupsWhereInput
    data: XOR<groupsUpdateWithoutGroupmembersInput, groupsUncheckedUpdateWithoutGroupmembersInput>
  }

  export type groupsUpdateWithoutGroupmembersInput = {
    groupname?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutGroupsNestedInput
  }

  export type groupsUncheckedUpdateWithoutGroupmembersInput = {
    gid?: IntFieldUpdateOperationsInput | number
    groupname?: StringFieldUpdateOperationsInput | string
    ownedby?: StringFieldUpdateOperationsInput | string
  }

  export type groupmembersCreateWithoutGroupsInput = {
    users: usersCreateNestedOneWithoutGroupmembersInput
  }

  export type groupmembersUncheckedCreateWithoutGroupsInput = {
    email: string
  }

  export type groupmembersCreateOrConnectWithoutGroupsInput = {
    where: groupmembersWhereUniqueInput
    create: XOR<groupmembersCreateWithoutGroupsInput, groupmembersUncheckedCreateWithoutGroupsInput>
  }

  export type groupmembersCreateManyGroupsInputEnvelope = {
    data: groupmembersCreateManyGroupsInput | groupmembersCreateManyGroupsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutGroupsInput = {
    email: string
    displayname: string
    userpassword: string
    createdat?: Date | string | null
    follows_follows_followeremailTousers?: followsCreateNestedManyWithoutUsers_follows_followeremailTousersInput
    follows_follows_followingemailTousers?: followsCreateNestedManyWithoutUsers_follows_followingemailTousersInput
    groupmembers?: groupmembersCreateNestedManyWithoutUsersInput
    likes?: likesCreateNestedManyWithoutUsersInput
    lists?: listsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutGroupsInput = {
    email: string
    displayname: string
    userpassword: string
    createdat?: Date | string | null
    follows_follows_followeremailTousers?: followsUncheckedCreateNestedManyWithoutUsers_follows_followeremailTousersInput
    follows_follows_followingemailTousers?: followsUncheckedCreateNestedManyWithoutUsers_follows_followingemailTousersInput
    groupmembers?: groupmembersUncheckedCreateNestedManyWithoutUsersInput
    likes?: likesUncheckedCreateNestedManyWithoutUsersInput
    lists?: listsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutGroupsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutGroupsInput, usersUncheckedCreateWithoutGroupsInput>
  }

  export type groupmembersUpsertWithWhereUniqueWithoutGroupsInput = {
    where: groupmembersWhereUniqueInput
    update: XOR<groupmembersUpdateWithoutGroupsInput, groupmembersUncheckedUpdateWithoutGroupsInput>
    create: XOR<groupmembersCreateWithoutGroupsInput, groupmembersUncheckedCreateWithoutGroupsInput>
  }

  export type groupmembersUpdateWithWhereUniqueWithoutGroupsInput = {
    where: groupmembersWhereUniqueInput
    data: XOR<groupmembersUpdateWithoutGroupsInput, groupmembersUncheckedUpdateWithoutGroupsInput>
  }

  export type groupmembersUpdateManyWithWhereWithoutGroupsInput = {
    where: groupmembersScalarWhereInput
    data: XOR<groupmembersUpdateManyMutationInput, groupmembersUncheckedUpdateManyWithoutGroupsInput>
  }

  export type groupmembersScalarWhereInput = {
    AND?: groupmembersScalarWhereInput | groupmembersScalarWhereInput[]
    OR?: groupmembersScalarWhereInput[]
    NOT?: groupmembersScalarWhereInput | groupmembersScalarWhereInput[]
    email?: StringFilter<"groupmembers"> | string
    gid?: IntFilter<"groupmembers"> | number
  }

  export type usersUpsertWithoutGroupsInput = {
    update: XOR<usersUpdateWithoutGroupsInput, usersUncheckedUpdateWithoutGroupsInput>
    create: XOR<usersCreateWithoutGroupsInput, usersUncheckedCreateWithoutGroupsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutGroupsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutGroupsInput, usersUncheckedUpdateWithoutGroupsInput>
  }

  export type usersUpdateWithoutGroupsInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follows_follows_followeremailTousers?: followsUpdateManyWithoutUsers_follows_followeremailTousersNestedInput
    follows_follows_followingemailTousers?: followsUpdateManyWithoutUsers_follows_followingemailTousersNestedInput
    groupmembers?: groupmembersUpdateManyWithoutUsersNestedInput
    likes?: likesUpdateManyWithoutUsersNestedInput
    lists?: listsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutGroupsInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follows_follows_followeremailTousers?: followsUncheckedUpdateManyWithoutUsers_follows_followeremailTousersNestedInput
    follows_follows_followingemailTousers?: followsUncheckedUpdateManyWithoutUsers_follows_followingemailTousersNestedInput
    groupmembers?: groupmembersUncheckedUpdateManyWithoutUsersNestedInput
    likes?: likesUncheckedUpdateManyWithoutUsersNestedInput
    lists?: listsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutLikesInput = {
    email: string
    displayname: string
    userpassword: string
    createdat?: Date | string | null
    follows_follows_followeremailTousers?: followsCreateNestedManyWithoutUsers_follows_followeremailTousersInput
    follows_follows_followingemailTousers?: followsCreateNestedManyWithoutUsers_follows_followingemailTousersInput
    groupmembers?: groupmembersCreateNestedManyWithoutUsersInput
    groups?: groupsCreateNestedManyWithoutUsersInput
    lists?: listsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutLikesInput = {
    email: string
    displayname: string
    userpassword: string
    createdat?: Date | string | null
    follows_follows_followeremailTousers?: followsUncheckedCreateNestedManyWithoutUsers_follows_followeremailTousersInput
    follows_follows_followingemailTousers?: followsUncheckedCreateNestedManyWithoutUsers_follows_followingemailTousersInput
    groupmembers?: groupmembersUncheckedCreateNestedManyWithoutUsersInput
    groups?: groupsUncheckedCreateNestedManyWithoutUsersInput
    lists?: listsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutLikesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutLikesInput, usersUncheckedCreateWithoutLikesInput>
  }

  export type listsCreateWithoutLikesInput = {
    listname: string
    listtype: $Enums.listtype
    listitems?: listitemsCreateNestedManyWithoutListsInput
    users: usersCreateNestedOneWithoutListsInput
  }

  export type listsUncheckedCreateWithoutLikesInput = {
    email: string
    listname: string
    listtype: $Enums.listtype
    listitems?: listitemsUncheckedCreateNestedManyWithoutListsInput
  }

  export type listsCreateOrConnectWithoutLikesInput = {
    where: listsWhereUniqueInput
    create: XOR<listsCreateWithoutLikesInput, listsUncheckedCreateWithoutLikesInput>
  }

  export type usersUpsertWithoutLikesInput = {
    update: XOR<usersUpdateWithoutLikesInput, usersUncheckedUpdateWithoutLikesInput>
    create: XOR<usersCreateWithoutLikesInput, usersUncheckedCreateWithoutLikesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutLikesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutLikesInput, usersUncheckedUpdateWithoutLikesInput>
  }

  export type usersUpdateWithoutLikesInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follows_follows_followeremailTousers?: followsUpdateManyWithoutUsers_follows_followeremailTousersNestedInput
    follows_follows_followingemailTousers?: followsUpdateManyWithoutUsers_follows_followingemailTousersNestedInput
    groupmembers?: groupmembersUpdateManyWithoutUsersNestedInput
    groups?: groupsUpdateManyWithoutUsersNestedInput
    lists?: listsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutLikesInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follows_follows_followeremailTousers?: followsUncheckedUpdateManyWithoutUsers_follows_followeremailTousersNestedInput
    follows_follows_followingemailTousers?: followsUncheckedUpdateManyWithoutUsers_follows_followingemailTousersNestedInput
    groupmembers?: groupmembersUncheckedUpdateManyWithoutUsersNestedInput
    groups?: groupsUncheckedUpdateManyWithoutUsersNestedInput
    lists?: listsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type listsUpsertWithoutLikesInput = {
    update: XOR<listsUpdateWithoutLikesInput, listsUncheckedUpdateWithoutLikesInput>
    create: XOR<listsCreateWithoutLikesInput, listsUncheckedCreateWithoutLikesInput>
    where?: listsWhereInput
  }

  export type listsUpdateToOneWithWhereWithoutLikesInput = {
    where?: listsWhereInput
    data: XOR<listsUpdateWithoutLikesInput, listsUncheckedUpdateWithoutLikesInput>
  }

  export type listsUpdateWithoutLikesInput = {
    listname?: StringFieldUpdateOperationsInput | string
    listtype?: EnumlisttypeFieldUpdateOperationsInput | $Enums.listtype
    listitems?: listitemsUpdateManyWithoutListsNestedInput
    users?: usersUpdateOneRequiredWithoutListsNestedInput
  }

  export type listsUncheckedUpdateWithoutLikesInput = {
    email?: StringFieldUpdateOperationsInput | string
    listname?: StringFieldUpdateOperationsInput | string
    listtype?: EnumlisttypeFieldUpdateOperationsInput | $Enums.listtype
    listitems?: listitemsUncheckedUpdateManyWithoutListsNestedInput
  }

  export type listsCreateWithoutListitemsInput = {
    listname: string
    listtype: $Enums.listtype
    likes?: likesCreateNestedManyWithoutListitemsInput
    users: usersCreateNestedOneWithoutListsInput
  }

  export type listsUncheckedCreateWithoutListitemsInput = {
    email: string
    listname: string
    listtype: $Enums.listtype
    likes?: likesUncheckedCreateNestedManyWithoutListitemsInput
  }

  export type listsCreateOrConnectWithoutListitemsInput = {
    where: listsWhereUniqueInput
    create: XOR<listsCreateWithoutListitemsInput, listsUncheckedCreateWithoutListitemsInput>
  }

  export type listsUpsertWithoutListitemsInput = {
    update: XOR<listsUpdateWithoutListitemsInput, listsUncheckedUpdateWithoutListitemsInput>
    create: XOR<listsCreateWithoutListitemsInput, listsUncheckedCreateWithoutListitemsInput>
    where?: listsWhereInput
  }

  export type listsUpdateToOneWithWhereWithoutListitemsInput = {
    where?: listsWhereInput
    data: XOR<listsUpdateWithoutListitemsInput, listsUncheckedUpdateWithoutListitemsInput>
  }

  export type listsUpdateWithoutListitemsInput = {
    listname?: StringFieldUpdateOperationsInput | string
    listtype?: EnumlisttypeFieldUpdateOperationsInput | $Enums.listtype
    likes?: likesUpdateManyWithoutListitemsNestedInput
    users?: usersUpdateOneRequiredWithoutListsNestedInput
  }

  export type listsUncheckedUpdateWithoutListitemsInput = {
    email?: StringFieldUpdateOperationsInput | string
    listname?: StringFieldUpdateOperationsInput | string
    listtype?: EnumlisttypeFieldUpdateOperationsInput | $Enums.listtype
    likes?: likesUncheckedUpdateManyWithoutListitemsNestedInput
  }

  export type likesCreateWithoutListitemsInput = {
    users: usersCreateNestedOneWithoutLikesInput
  }

  export type likesUncheckedCreateWithoutListitemsInput = {
    likeremail: string
  }

  export type likesCreateOrConnectWithoutListitemsInput = {
    where: likesWhereUniqueInput
    create: XOR<likesCreateWithoutListitemsInput, likesUncheckedCreateWithoutListitemsInput>
  }

  export type likesCreateManyListitemsInputEnvelope = {
    data: likesCreateManyListitemsInput | likesCreateManyListitemsInput[]
    skipDuplicates?: boolean
  }

  export type listitemsCreateWithoutListsInput = {
    rankinginlist: number
    itemid: number
  }

  export type listitemsUncheckedCreateWithoutListsInput = {
    rankinginlist: number
    itemid: number
  }

  export type listitemsCreateOrConnectWithoutListsInput = {
    where: listitemsWhereUniqueInput
    create: XOR<listitemsCreateWithoutListsInput, listitemsUncheckedCreateWithoutListsInput>
  }

  export type listitemsCreateManyListsInputEnvelope = {
    data: listitemsCreateManyListsInput | listitemsCreateManyListsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutListsInput = {
    email: string
    displayname: string
    userpassword: string
    createdat?: Date | string | null
    follows_follows_followeremailTousers?: followsCreateNestedManyWithoutUsers_follows_followeremailTousersInput
    follows_follows_followingemailTousers?: followsCreateNestedManyWithoutUsers_follows_followingemailTousersInput
    groupmembers?: groupmembersCreateNestedManyWithoutUsersInput
    groups?: groupsCreateNestedManyWithoutUsersInput
    likes?: likesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutListsInput = {
    email: string
    displayname: string
    userpassword: string
    createdat?: Date | string | null
    follows_follows_followeremailTousers?: followsUncheckedCreateNestedManyWithoutUsers_follows_followeremailTousersInput
    follows_follows_followingemailTousers?: followsUncheckedCreateNestedManyWithoutUsers_follows_followingemailTousersInput
    groupmembers?: groupmembersUncheckedCreateNestedManyWithoutUsersInput
    groups?: groupsUncheckedCreateNestedManyWithoutUsersInput
    likes?: likesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutListsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutListsInput, usersUncheckedCreateWithoutListsInput>
  }

  export type likesUpsertWithWhereUniqueWithoutListitemsInput = {
    where: likesWhereUniqueInput
    update: XOR<likesUpdateWithoutListitemsInput, likesUncheckedUpdateWithoutListitemsInput>
    create: XOR<likesCreateWithoutListitemsInput, likesUncheckedCreateWithoutListitemsInput>
  }

  export type likesUpdateWithWhereUniqueWithoutListitemsInput = {
    where: likesWhereUniqueInput
    data: XOR<likesUpdateWithoutListitemsInput, likesUncheckedUpdateWithoutListitemsInput>
  }

  export type likesUpdateManyWithWhereWithoutListitemsInput = {
    where: likesScalarWhereInput
    data: XOR<likesUpdateManyMutationInput, likesUncheckedUpdateManyWithoutListitemsInput>
  }

  export type likesScalarWhereInput = {
    AND?: likesScalarWhereInput | likesScalarWhereInput[]
    OR?: likesScalarWhereInput[]
    NOT?: likesScalarWhereInput | likesScalarWhereInput[]
    likeremail?: StringFilter<"likes"> | string
    likingemail?: StringFilter<"likes"> | string
    listname?: StringFilter<"likes"> | string
  }

  export type listitemsUpsertWithWhereUniqueWithoutListsInput = {
    where: listitemsWhereUniqueInput
    update: XOR<listitemsUpdateWithoutListsInput, listitemsUncheckedUpdateWithoutListsInput>
    create: XOR<listitemsCreateWithoutListsInput, listitemsUncheckedCreateWithoutListsInput>
  }

  export type listitemsUpdateWithWhereUniqueWithoutListsInput = {
    where: listitemsWhereUniqueInput
    data: XOR<listitemsUpdateWithoutListsInput, listitemsUncheckedUpdateWithoutListsInput>
  }

  export type listitemsUpdateManyWithWhereWithoutListsInput = {
    where: listitemsScalarWhereInput
    data: XOR<listitemsUpdateManyMutationInput, listitemsUncheckedUpdateManyWithoutListsInput>
  }

  export type listitemsScalarWhereInput = {
    AND?: listitemsScalarWhereInput | listitemsScalarWhereInput[]
    OR?: listitemsScalarWhereInput[]
    NOT?: listitemsScalarWhereInput | listitemsScalarWhereInput[]
    email?: StringFilter<"listitems"> | string
    listname?: StringFilter<"listitems"> | string
    rankinginlist?: IntFilter<"listitems"> | number
    itemid?: IntFilter<"listitems"> | number
  }

  export type usersUpsertWithoutListsInput = {
    update: XOR<usersUpdateWithoutListsInput, usersUncheckedUpdateWithoutListsInput>
    create: XOR<usersCreateWithoutListsInput, usersUncheckedCreateWithoutListsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutListsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutListsInput, usersUncheckedUpdateWithoutListsInput>
  }

  export type usersUpdateWithoutListsInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follows_follows_followeremailTousers?: followsUpdateManyWithoutUsers_follows_followeremailTousersNestedInput
    follows_follows_followingemailTousers?: followsUpdateManyWithoutUsers_follows_followingemailTousersNestedInput
    groupmembers?: groupmembersUpdateManyWithoutUsersNestedInput
    groups?: groupsUpdateManyWithoutUsersNestedInput
    likes?: likesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutListsInput = {
    email?: StringFieldUpdateOperationsInput | string
    displayname?: StringFieldUpdateOperationsInput | string
    userpassword?: StringFieldUpdateOperationsInput | string
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    follows_follows_followeremailTousers?: followsUncheckedUpdateManyWithoutUsers_follows_followeremailTousersNestedInput
    follows_follows_followingemailTousers?: followsUncheckedUpdateManyWithoutUsers_follows_followingemailTousersNestedInput
    groupmembers?: groupmembersUncheckedUpdateManyWithoutUsersNestedInput
    groups?: groupsUncheckedUpdateManyWithoutUsersNestedInput
    likes?: likesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type followsCreateWithoutUsers_follows_followeremailTousersInput = {
    users_follows_followingemailTousers: usersCreateNestedOneWithoutFollows_follows_followingemailTousersInput
  }

  export type followsUncheckedCreateWithoutUsers_follows_followeremailTousersInput = {
    followingemail: string
  }

  export type followsCreateOrConnectWithoutUsers_follows_followeremailTousersInput = {
    where: followsWhereUniqueInput
    create: XOR<followsCreateWithoutUsers_follows_followeremailTousersInput, followsUncheckedCreateWithoutUsers_follows_followeremailTousersInput>
  }

  export type followsCreateManyUsers_follows_followeremailTousersInputEnvelope = {
    data: followsCreateManyUsers_follows_followeremailTousersInput | followsCreateManyUsers_follows_followeremailTousersInput[]
    skipDuplicates?: boolean
  }

  export type followsCreateWithoutUsers_follows_followingemailTousersInput = {
    users_follows_followeremailTousers: usersCreateNestedOneWithoutFollows_follows_followeremailTousersInput
  }

  export type followsUncheckedCreateWithoutUsers_follows_followingemailTousersInput = {
    followeremail: string
  }

  export type followsCreateOrConnectWithoutUsers_follows_followingemailTousersInput = {
    where: followsWhereUniqueInput
    create: XOR<followsCreateWithoutUsers_follows_followingemailTousersInput, followsUncheckedCreateWithoutUsers_follows_followingemailTousersInput>
  }

  export type followsCreateManyUsers_follows_followingemailTousersInputEnvelope = {
    data: followsCreateManyUsers_follows_followingemailTousersInput | followsCreateManyUsers_follows_followingemailTousersInput[]
    skipDuplicates?: boolean
  }

  export type groupmembersCreateWithoutUsersInput = {
    groups: groupsCreateNestedOneWithoutGroupmembersInput
  }

  export type groupmembersUncheckedCreateWithoutUsersInput = {
    gid: number
  }

  export type groupmembersCreateOrConnectWithoutUsersInput = {
    where: groupmembersWhereUniqueInput
    create: XOR<groupmembersCreateWithoutUsersInput, groupmembersUncheckedCreateWithoutUsersInput>
  }

  export type groupmembersCreateManyUsersInputEnvelope = {
    data: groupmembersCreateManyUsersInput | groupmembersCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type groupsCreateWithoutUsersInput = {
    groupname: string
    groupmembers?: groupmembersCreateNestedManyWithoutGroupsInput
  }

  export type groupsUncheckedCreateWithoutUsersInput = {
    gid?: number
    groupname: string
    groupmembers?: groupmembersUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type groupsCreateOrConnectWithoutUsersInput = {
    where: groupsWhereUniqueInput
    create: XOR<groupsCreateWithoutUsersInput, groupsUncheckedCreateWithoutUsersInput>
  }

  export type groupsCreateManyUsersInputEnvelope = {
    data: groupsCreateManyUsersInput | groupsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type likesCreateWithoutUsersInput = {
    listitems: listsCreateNestedOneWithoutLikesInput
  }

  export type likesUncheckedCreateWithoutUsersInput = {
    likingemail: string
    listname: string
  }

  export type likesCreateOrConnectWithoutUsersInput = {
    where: likesWhereUniqueInput
    create: XOR<likesCreateWithoutUsersInput, likesUncheckedCreateWithoutUsersInput>
  }

  export type likesCreateManyUsersInputEnvelope = {
    data: likesCreateManyUsersInput | likesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type listsCreateWithoutUsersInput = {
    listname: string
    listtype: $Enums.listtype
    likes?: likesCreateNestedManyWithoutListitemsInput
    listitems?: listitemsCreateNestedManyWithoutListsInput
  }

  export type listsUncheckedCreateWithoutUsersInput = {
    listname: string
    listtype: $Enums.listtype
    likes?: likesUncheckedCreateNestedManyWithoutListitemsInput
    listitems?: listitemsUncheckedCreateNestedManyWithoutListsInput
  }

  export type listsCreateOrConnectWithoutUsersInput = {
    where: listsWhereUniqueInput
    create: XOR<listsCreateWithoutUsersInput, listsUncheckedCreateWithoutUsersInput>
  }

  export type listsCreateManyUsersInputEnvelope = {
    data: listsCreateManyUsersInput | listsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type followsUpsertWithWhereUniqueWithoutUsers_follows_followeremailTousersInput = {
    where: followsWhereUniqueInput
    update: XOR<followsUpdateWithoutUsers_follows_followeremailTousersInput, followsUncheckedUpdateWithoutUsers_follows_followeremailTousersInput>
    create: XOR<followsCreateWithoutUsers_follows_followeremailTousersInput, followsUncheckedCreateWithoutUsers_follows_followeremailTousersInput>
  }

  export type followsUpdateWithWhereUniqueWithoutUsers_follows_followeremailTousersInput = {
    where: followsWhereUniqueInput
    data: XOR<followsUpdateWithoutUsers_follows_followeremailTousersInput, followsUncheckedUpdateWithoutUsers_follows_followeremailTousersInput>
  }

  export type followsUpdateManyWithWhereWithoutUsers_follows_followeremailTousersInput = {
    where: followsScalarWhereInput
    data: XOR<followsUpdateManyMutationInput, followsUncheckedUpdateManyWithoutUsers_follows_followeremailTousersInput>
  }

  export type followsScalarWhereInput = {
    AND?: followsScalarWhereInput | followsScalarWhereInput[]
    OR?: followsScalarWhereInput[]
    NOT?: followsScalarWhereInput | followsScalarWhereInput[]
    followeremail?: StringFilter<"follows"> | string
    followingemail?: StringFilter<"follows"> | string
  }

  export type followsUpsertWithWhereUniqueWithoutUsers_follows_followingemailTousersInput = {
    where: followsWhereUniqueInput
    update: XOR<followsUpdateWithoutUsers_follows_followingemailTousersInput, followsUncheckedUpdateWithoutUsers_follows_followingemailTousersInput>
    create: XOR<followsCreateWithoutUsers_follows_followingemailTousersInput, followsUncheckedCreateWithoutUsers_follows_followingemailTousersInput>
  }

  export type followsUpdateWithWhereUniqueWithoutUsers_follows_followingemailTousersInput = {
    where: followsWhereUniqueInput
    data: XOR<followsUpdateWithoutUsers_follows_followingemailTousersInput, followsUncheckedUpdateWithoutUsers_follows_followingemailTousersInput>
  }

  export type followsUpdateManyWithWhereWithoutUsers_follows_followingemailTousersInput = {
    where: followsScalarWhereInput
    data: XOR<followsUpdateManyMutationInput, followsUncheckedUpdateManyWithoutUsers_follows_followingemailTousersInput>
  }

  export type groupmembersUpsertWithWhereUniqueWithoutUsersInput = {
    where: groupmembersWhereUniqueInput
    update: XOR<groupmembersUpdateWithoutUsersInput, groupmembersUncheckedUpdateWithoutUsersInput>
    create: XOR<groupmembersCreateWithoutUsersInput, groupmembersUncheckedCreateWithoutUsersInput>
  }

  export type groupmembersUpdateWithWhereUniqueWithoutUsersInput = {
    where: groupmembersWhereUniqueInput
    data: XOR<groupmembersUpdateWithoutUsersInput, groupmembersUncheckedUpdateWithoutUsersInput>
  }

  export type groupmembersUpdateManyWithWhereWithoutUsersInput = {
    where: groupmembersScalarWhereInput
    data: XOR<groupmembersUpdateManyMutationInput, groupmembersUncheckedUpdateManyWithoutUsersInput>
  }

  export type groupsUpsertWithWhereUniqueWithoutUsersInput = {
    where: groupsWhereUniqueInput
    update: XOR<groupsUpdateWithoutUsersInput, groupsUncheckedUpdateWithoutUsersInput>
    create: XOR<groupsCreateWithoutUsersInput, groupsUncheckedCreateWithoutUsersInput>
  }

  export type groupsUpdateWithWhereUniqueWithoutUsersInput = {
    where: groupsWhereUniqueInput
    data: XOR<groupsUpdateWithoutUsersInput, groupsUncheckedUpdateWithoutUsersInput>
  }

  export type groupsUpdateManyWithWhereWithoutUsersInput = {
    where: groupsScalarWhereInput
    data: XOR<groupsUpdateManyMutationInput, groupsUncheckedUpdateManyWithoutUsersInput>
  }

  export type groupsScalarWhereInput = {
    AND?: groupsScalarWhereInput | groupsScalarWhereInput[]
    OR?: groupsScalarWhereInput[]
    NOT?: groupsScalarWhereInput | groupsScalarWhereInput[]
    gid?: IntFilter<"groups"> | number
    groupname?: StringFilter<"groups"> | string
    ownedby?: StringFilter<"groups"> | string
  }

  export type likesUpsertWithWhereUniqueWithoutUsersInput = {
    where: likesWhereUniqueInput
    update: XOR<likesUpdateWithoutUsersInput, likesUncheckedUpdateWithoutUsersInput>
    create: XOR<likesCreateWithoutUsersInput, likesUncheckedCreateWithoutUsersInput>
  }

  export type likesUpdateWithWhereUniqueWithoutUsersInput = {
    where: likesWhereUniqueInput
    data: XOR<likesUpdateWithoutUsersInput, likesUncheckedUpdateWithoutUsersInput>
  }

  export type likesUpdateManyWithWhereWithoutUsersInput = {
    where: likesScalarWhereInput
    data: XOR<likesUpdateManyMutationInput, likesUncheckedUpdateManyWithoutUsersInput>
  }

  export type listsUpsertWithWhereUniqueWithoutUsersInput = {
    where: listsWhereUniqueInput
    update: XOR<listsUpdateWithoutUsersInput, listsUncheckedUpdateWithoutUsersInput>
    create: XOR<listsCreateWithoutUsersInput, listsUncheckedCreateWithoutUsersInput>
  }

  export type listsUpdateWithWhereUniqueWithoutUsersInput = {
    where: listsWhereUniqueInput
    data: XOR<listsUpdateWithoutUsersInput, listsUncheckedUpdateWithoutUsersInput>
  }

  export type listsUpdateManyWithWhereWithoutUsersInput = {
    where: listsScalarWhereInput
    data: XOR<listsUpdateManyMutationInput, listsUncheckedUpdateManyWithoutUsersInput>
  }

  export type listsScalarWhereInput = {
    AND?: listsScalarWhereInput | listsScalarWhereInput[]
    OR?: listsScalarWhereInput[]
    NOT?: listsScalarWhereInput | listsScalarWhereInput[]
    email?: StringFilter<"lists"> | string
    listname?: StringFilter<"lists"> | string
    listtype?: EnumlisttypeFilter<"lists"> | $Enums.listtype
  }

  export type groupmembersCreateManyGroupsInput = {
    email: string
  }

  export type groupmembersUpdateWithoutGroupsInput = {
    users?: usersUpdateOneRequiredWithoutGroupmembersNestedInput
  }

  export type groupmembersUncheckedUpdateWithoutGroupsInput = {
    email?: StringFieldUpdateOperationsInput | string
  }

  export type groupmembersUncheckedUpdateManyWithoutGroupsInput = {
    email?: StringFieldUpdateOperationsInput | string
  }

  export type likesCreateManyListitemsInput = {
    likeremail: string
  }

  export type listitemsCreateManyListsInput = {
    rankinginlist: number
    itemid: number
  }

  export type likesUpdateWithoutListitemsInput = {
    users?: usersUpdateOneRequiredWithoutLikesNestedInput
  }

  export type likesUncheckedUpdateWithoutListitemsInput = {
    likeremail?: StringFieldUpdateOperationsInput | string
  }

  export type likesUncheckedUpdateManyWithoutListitemsInput = {
    likeremail?: StringFieldUpdateOperationsInput | string
  }

  export type listitemsUpdateWithoutListsInput = {
    rankinginlist?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
  }

  export type listitemsUncheckedUpdateWithoutListsInput = {
    rankinginlist?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
  }

  export type listitemsUncheckedUpdateManyWithoutListsInput = {
    rankinginlist?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
  }

  export type followsCreateManyUsers_follows_followeremailTousersInput = {
    followingemail: string
  }

  export type followsCreateManyUsers_follows_followingemailTousersInput = {
    followeremail: string
  }

  export type groupmembersCreateManyUsersInput = {
    gid: number
  }

  export type groupsCreateManyUsersInput = {
    gid?: number
    groupname: string
  }

  export type likesCreateManyUsersInput = {
    likingemail: string
    listname: string
  }

  export type listsCreateManyUsersInput = {
    listname: string
    listtype: $Enums.listtype
  }

  export type followsUpdateWithoutUsers_follows_followeremailTousersInput = {
    users_follows_followingemailTousers?: usersUpdateOneRequiredWithoutFollows_follows_followingemailTousersNestedInput
  }

  export type followsUncheckedUpdateWithoutUsers_follows_followeremailTousersInput = {
    followingemail?: StringFieldUpdateOperationsInput | string
  }

  export type followsUncheckedUpdateManyWithoutUsers_follows_followeremailTousersInput = {
    followingemail?: StringFieldUpdateOperationsInput | string
  }

  export type followsUpdateWithoutUsers_follows_followingemailTousersInput = {
    users_follows_followeremailTousers?: usersUpdateOneRequiredWithoutFollows_follows_followeremailTousersNestedInput
  }

  export type followsUncheckedUpdateWithoutUsers_follows_followingemailTousersInput = {
    followeremail?: StringFieldUpdateOperationsInput | string
  }

  export type followsUncheckedUpdateManyWithoutUsers_follows_followingemailTousersInput = {
    followeremail?: StringFieldUpdateOperationsInput | string
  }

  export type groupmembersUpdateWithoutUsersInput = {
    groups?: groupsUpdateOneRequiredWithoutGroupmembersNestedInput
  }

  export type groupmembersUncheckedUpdateWithoutUsersInput = {
    gid?: IntFieldUpdateOperationsInput | number
  }

  export type groupmembersUncheckedUpdateManyWithoutUsersInput = {
    gid?: IntFieldUpdateOperationsInput | number
  }

  export type groupsUpdateWithoutUsersInput = {
    groupname?: StringFieldUpdateOperationsInput | string
    groupmembers?: groupmembersUpdateManyWithoutGroupsNestedInput
  }

  export type groupsUncheckedUpdateWithoutUsersInput = {
    gid?: IntFieldUpdateOperationsInput | number
    groupname?: StringFieldUpdateOperationsInput | string
    groupmembers?: groupmembersUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type groupsUncheckedUpdateManyWithoutUsersInput = {
    gid?: IntFieldUpdateOperationsInput | number
    groupname?: StringFieldUpdateOperationsInput | string
  }

  export type likesUpdateWithoutUsersInput = {
    listitems?: listsUpdateOneRequiredWithoutLikesNestedInput
  }

  export type likesUncheckedUpdateWithoutUsersInput = {
    likingemail?: StringFieldUpdateOperationsInput | string
    listname?: StringFieldUpdateOperationsInput | string
  }

  export type likesUncheckedUpdateManyWithoutUsersInput = {
    likingemail?: StringFieldUpdateOperationsInput | string
    listname?: StringFieldUpdateOperationsInput | string
  }

  export type listsUpdateWithoutUsersInput = {
    listname?: StringFieldUpdateOperationsInput | string
    listtype?: EnumlisttypeFieldUpdateOperationsInput | $Enums.listtype
    likes?: likesUpdateManyWithoutListitemsNestedInput
    listitems?: listitemsUpdateManyWithoutListsNestedInput
  }

  export type listsUncheckedUpdateWithoutUsersInput = {
    listname?: StringFieldUpdateOperationsInput | string
    listtype?: EnumlisttypeFieldUpdateOperationsInput | $Enums.listtype
    likes?: likesUncheckedUpdateManyWithoutListitemsNestedInput
    listitems?: listitemsUncheckedUpdateManyWithoutListsNestedInput
  }

  export type listsUncheckedUpdateManyWithoutUsersInput = {
    listname?: StringFieldUpdateOperationsInput | string
    listtype?: EnumlisttypeFieldUpdateOperationsInput | $Enums.listtype
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use GroupsCountOutputTypeDefaultArgs instead
     */
    export type GroupsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ListsCountOutputTypeDefaultArgs instead
     */
    export type ListsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ListsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use animeDefaultArgs instead
     */
    export type animeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = animeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use followsDefaultArgs instead
     */
    export type followsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = followsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use groupmembersDefaultArgs instead
     */
    export type groupmembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = groupmembersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use groupsDefaultArgs instead
     */
    export type groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = groupsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use likesDefaultArgs instead
     */
    export type likesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = likesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use listitemsDefaultArgs instead
     */
    export type listitemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = listitemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use listsDefaultArgs instead
     */
    export type listsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = listsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use moviesDefaultArgs instead
     */
    export type moviesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = moviesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use songsDefaultArgs instead
     */
    export type songsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = songsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use videogamesDefaultArgs instead
     */
    export type videogamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = videogamesDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}